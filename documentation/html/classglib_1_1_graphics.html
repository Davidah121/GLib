<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLIB: glib::Graphics Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLIB<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A simple C++ library for general software development.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>glib</b></li><li class="navelem"><a class="el" href="classglib_1_1_graphics.html">Graphics</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classglib_1_1_graphics-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">glib::Graphics Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a1c46d8c2f837e63b24755b187f8ccdae"><td class="memItemLeft" align="right" valign="top"><a id="a1c46d8c2f837e63b24755b187f8ccdae" name="a1c46d8c2f837e63b24755b187f8ccdae"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>init</b> ()</td></tr>
<tr class="memdesc:a1c46d8c2f837e63b24755b187f8ccdae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the <a class="el" href="classglib_1_1_graphics.html">Graphics</a> class for drawing. It loads in a default font for drawing text. Dispose should be called if this function has been called. <br /></td></tr>
<tr class="separator:a1c46d8c2f837e63b24755b187f8ccdae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af01d090215139f8aa907e5798eeebaa0"><td class="memItemLeft" align="right" valign="top"><a id="af01d090215139f8aa907e5798eeebaa0" name="af01d090215139f8aa907e5798eeebaa0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>dispose</b> ()</td></tr>
<tr class="memdesc:af01d090215139f8aa907e5798eeebaa0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Disposes of the memory allocated by the <a class="el" href="classglib_1_1_graphics.html">Graphics</a> class. <br /></td></tr>
<tr class="separator:af01d090215139f8aa907e5798eeebaa0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d860db215c5227ba1703eb93f9bbc4e"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a7d860db215c5227ba1703eb93f9bbc4e">clearImage</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:a7d860db215c5227ba1703eb93f9bbc4e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Clears the specified Image* to the draw color.  <a href="classglib_1_1_graphics.html#a7d860db215c5227ba1703eb93f9bbc4e">More...</a><br /></td></tr>
<tr class="separator:a7d860db215c5227ba1703eb93f9bbc4e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ede68aed7abda6e9ad9b927170aa842"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a2ede68aed7abda6e9ad9b927170aa842">drawPixel</a> (int x, int y, <a class="el" href="structglib_1_1_color.html">Color</a> c, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:a2ede68aed7abda6e9ad9b927170aa842"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a pixel to the specified image using Porter Duff rules.  <a href="classglib_1_1_graphics.html#a2ede68aed7abda6e9ad9b927170aa842">More...</a><br /></td></tr>
<tr class="separator:a2ede68aed7abda6e9ad9b927170aa842"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad7ee57c195787298c8a0a2413ed49a38"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#ad7ee57c195787298c8a0a2413ed49a38">drawPixel</a> (double x, double y, <a class="el" href="structglib_1_1_color.html">Color</a> c, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:ad7ee57c195787298c8a0a2413ed49a38"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a pixel to the specified image using Porter Duff rules. This function can draw up to 4 different pixels due to the specified point not directly lining up with the pixel grid.  <a href="classglib_1_1_graphics.html#ad7ee57c195787298c8a0a2413ed49a38">More...</a><br /></td></tr>
<tr class="separator:ad7ee57c195787298c8a0a2413ed49a38"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab3606cf0cc23415b750b84696be9d2ca"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#ab3606cf0cc23415b750b84696be9d2ca">blend</a> (<a class="el" href="structglib_1_1_color.html">Color</a> src, <a class="el" href="structglib_1_1_color.html">Color</a> dest)</td></tr>
<tr class="memdesc:ab3606cf0cc23415b750b84696be9d2ca"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blends 2 colors using Porter Duff rules. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#ab3606cf0cc23415b750b84696be9d2ca">More...</a><br /></td></tr>
<tr class="separator:ab3606cf0cc23415b750b84696be9d2ca"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ee604e5ee9e0dcfe89d3af935b6d080"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a9ee604e5ee9e0dcfe89d3af935b6d080">lerp</a> (<a class="el" href="structglib_1_1_color.html">Color</a> src, <a class="el" href="structglib_1_1_color.html">Color</a> dest, double lerpVal)</td></tr>
<tr class="memdesc:a9ee604e5ee9e0dcfe89d3af935b6d080"><td class="mdescLeft">&#160;</td><td class="mdescRight">Linearly blends 2 colors together. At value 0, src is the output color. At value 1, dest is the output color.  <a href="classglib_1_1_graphics.html#a9ee604e5ee9e0dcfe89d3af935b6d080">More...</a><br /></td></tr>
<tr class="separator:a9ee604e5ee9e0dcfe89d3af935b6d080"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4b7a04d7634bd263235cefb7433b5b83"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a4b7a04d7634bd263235cefb7433b5b83">drawRect</a> (int x, int y, int x2, int y2, bool outline, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:a4b7a04d7634bd263235cefb7433b5b83"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a rectangle using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#a4b7a04d7634bd263235cefb7433b5b83">More...</a><br /></td></tr>
<tr class="separator:a4b7a04d7634bd263235cefb7433b5b83"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1a1475c9ad7f98719cd39ed5ab6c9ebc"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a1a1475c9ad7f98719cd39ed5ab6c9ebc">drawLine</a> (int x, int y, int x2, int y2, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:a1a1475c9ad7f98719cd39ed5ab6c9ebc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a <a class="el" href="classglib_1_1_line.html">Line</a> using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#a1a1475c9ad7f98719cd39ed5ab6c9ebc">More...</a><br /></td></tr>
<tr class="separator:a1a1475c9ad7f98719cd39ed5ab6c9ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf513c3dc5c58d0791079181e9a37cd7"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#aaf513c3dc5c58d0791079181e9a37cd7">drawCircle</a> (int x, int y, int radius, bool outline, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:aaf513c3dc5c58d0791079181e9a37cd7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a circle using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#aaf513c3dc5c58d0791079181e9a37cd7">More...</a><br /></td></tr>
<tr class="separator:aaf513c3dc5c58d0791079181e9a37cd7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abbdefd80ce18636bc379d66da2163222"><td class="memItemLeft" align="right" valign="top"><a id="abbdefd80ce18636bc379d66da2163222" name="abbdefd80ce18636bc379d66da2163222"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>testDrawTriangle</b> (int x1, int y1, int x2, int y2, int x3, int y3, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:abbdefd80ce18636bc379d66da2163222"><td class="mdescLeft">&#160;</td><td class="mdescRight">Test draw function. Should be ignored. <br /></td></tr>
<tr class="separator:abbdefd80ce18636bc379d66da2163222"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaf6e7568e21d0f18e83c1e47abef2a28"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#aaf6e7568e21d0f18e83c1e47abef2a28">drawTriangle</a> (int x1, int y1, int x2, int y2, int x3, int y3, bool outline, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:aaf6e7568e21d0f18e83c1e47abef2a28"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a triangle using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#aaf6e7568e21d0f18e83c1e47abef2a28">More...</a><br /></td></tr>
<tr class="separator:aaf6e7568e21d0f18e83c1e47abef2a28"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adda98ffe0d32fac75c82c79835b31643"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#adda98ffe0d32fac75c82c79835b31643">drawTexturedTriangle</a> (<a class="el" href="classglib_1_1_vec4f.html">Vec4f</a> p1, <a class="el" href="classglib_1_1_vec4f.html">Vec4f</a> p2, <a class="el" href="classglib_1_1_vec4f.html">Vec4f</a> p3, <a class="el" href="classglib_1_1_image.html">Image</a> *texture, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:adda98ffe0d32fac75c82c79835b31643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a triangle using the specified image. Is not affected by the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#adda98ffe0d32fac75c82c79835b31643">More...</a><br /></td></tr>
<tr class="separator:adda98ffe0d32fac75c82c79835b31643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa796cf0e60cccf00bfd6db7265034291"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#aa796cf0e60cccf00bfd6db7265034291">drawImage</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, int x, int y, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:aa796cf0e60cccf00bfd6db7265034291"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an <a class="el" href="classglib_1_1_image.html">Image</a>. The active color has no influence. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#aa796cf0e60cccf00bfd6db7265034291">More...</a><br /></td></tr>
<tr class="separator:aa796cf0e60cccf00bfd6db7265034291"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adfcad2373a8083e8b90fa82f28c3413d"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#adfcad2373a8083e8b90fa82f28c3413d">drawSprite</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, int x, int y, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:adfcad2373a8083e8b90fa82f28c3413d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws an <a class="el" href="classglib_1_1_image.html">Image</a> that is modified by the active drawing color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#adfcad2373a8083e8b90fa82f28c3413d">More...</a><br /></td></tr>
<tr class="separator:adfcad2373a8083e8b90fa82f28c3413d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acc89b72431ad7ff7933397b8ac354902"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#acc89b72431ad7ff7933397b8ac354902">drawSpritePart</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, int x, int y, int imgX, int imgY, int imgW, int imgH, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:acc89b72431ad7ff7933397b8ac354902"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a part of an <a class="el" href="classglib_1_1_image.html">Image</a> that will be modified by the active drawing color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#acc89b72431ad7ff7933397b8ac354902">More...</a><br /></td></tr>
<tr class="separator:acc89b72431ad7ff7933397b8ac354902"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6828073d7be88610fa338811e9a7d5fe"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a6828073d7be88610fa338811e9a7d5fe">drawText</a> (std::string str, int x, int y, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:a6828073d7be88610fa338811e9a7d5fe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the specified text using the active font. It is affected by the active drawing color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#a6828073d7be88610fa338811e9a7d5fe">More...</a><br /></td></tr>
<tr class="separator:a6828073d7be88610fa338811e9a7d5fe"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab1c69033fc237648dc82d64a0712bbd0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#ab1c69033fc237648dc82d64a0712bbd0">drawTextLimits</a> (std::string str, int x, int y, int maxWidth, int maxHeight, bool useLineBreak, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:ab1c69033fc237648dc82d64a0712bbd0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws the specified text using the active font. It is affected by the active drawing color. Adds additional limits such as the maximum width and maximum height. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used.  <a href="classglib_1_1_graphics.html#ab1c69033fc237648dc82d64a0712bbd0">More...</a><br /></td></tr>
<tr class="separator:ab1c69033fc237648dc82d64a0712bbd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af1c8f49d1eb8a170b8ca12567ca011a0"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#af1c8f49d1eb8a170b8ca12567ca011a0">drawPolygon</a> (<a class="el" href="classglib_1_1_vec2f.html">Vec2f</a> *points, int size, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:af1c8f49d1eb8a170b8ca12567ca011a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a polygon using the active draw color. Is affected by the current fill rule. May be removed as VectorGraphics accomplishes the same thing but will have more options.  <a href="classglib_1_1_graphics.html#af1c8f49d1eb8a170b8ca12567ca011a0">More...</a><br /></td></tr>
<tr class="separator:af1c8f49d1eb8a170b8ca12567ca011a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0646616a90f27f2e0408bb45711d25ae"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a0646616a90f27f2e0408bb45711d25ae">drawModel</a> (<a class="el" href="classglib_1_1_model.html">Model</a> *model, <a class="el" href="classglib_1_1_image.html">Image</a> *texture, <a class="el" href="classglib_1_1_image.html">Image</a> *surf)</td></tr>
<tr class="memdesc:a0646616a90f27f2e0408bb45711d25ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Draws a model using the active draw color or texture. Follows OpenGL drawing. Only 2D shapes are supported. Expects position, and if desired texture, to be defined in the model. Expects position and texture to be Model::TYPE_VEC2.  <a href="classglib_1_1_graphics.html#a0646616a90f27f2e0408bb45711d25ae">More...</a><br /></td></tr>
<tr class="separator:a0646616a90f27f2e0408bb45711d25ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6a66498b02ba6afa2589fbe4fa88a33"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#af6a66498b02ba6afa2589fbe4fa88a33">setClippingRect</a> (<a class="el" href="classglib_1_1_box2_d.html">Box2D</a> b)</td></tr>
<tr class="memdesc:af6a66498b02ba6afa2589fbe4fa88a33"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a rectangle where drawing will be allowed for the following drawing operations. Anything outside of the rectangle is not drawn.  <a href="classglib_1_1_graphics.html#af6a66498b02ba6afa2589fbe4fa88a33">More...</a><br /></td></tr>
<tr class="separator:af6a66498b02ba6afa2589fbe4fa88a33"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44ceda2ca0404aa740fd302225965e82"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classglib_1_1_box2_d.html">Box2D</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a44ceda2ca0404aa740fd302225965e82">getClippingRect</a> ()</td></tr>
<tr class="memdesc:a44ceda2ca0404aa740fd302225965e82"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the clipping rectangle currently used. Anything outside of the rectangle is not drawn.  <a href="classglib_1_1_graphics.html#a44ceda2ca0404aa740fd302225965e82">More...</a><br /></td></tr>
<tr class="separator:a44ceda2ca0404aa740fd302225965e82"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa79c7dcf3febdce994e1ac2e1a9f16f6"><td class="memItemLeft" align="right" valign="top"><a id="aa79c7dcf3febdce994e1ac2e1a9f16f6" name="aa79c7dcf3febdce994e1ac2e1a9f16f6"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>resetClippingPlane</b> ()</td></tr>
<tr class="memdesc:aa79c7dcf3febdce994e1ac2e1a9f16f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resets the clipping rectangle. The defaults are: x &gt;= 0 &amp;&amp; x&lt;=65535 y &gt;= 0 &amp;&amp; y&lt;=65535. <br /></td></tr>
<tr class="separator:aa79c7dcf3febdce994e1ac2e1a9f16f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7743fdbb26b410deb9cb665dd5869c15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a7743fdbb26b410deb9cb665dd5869c15">setColor</a> (<a class="el" href="structglib_1_1_color.html">Color</a> c)</td></tr>
<tr class="memdesc:a7743fdbb26b410deb9cb665dd5869c15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently active drawing color.  <a href="classglib_1_1_graphics.html#a7743fdbb26b410deb9cb665dd5869c15">More...</a><br /></td></tr>
<tr class="separator:a7743fdbb26b410deb9cb665dd5869c15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80c9c2db8bb90e97f2fa8e5b94c1247f"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a80c9c2db8bb90e97f2fa8e5b94c1247f">getColor</a> ()</td></tr>
<tr class="memdesc:a80c9c2db8bb90e97f2fa8e5b94c1247f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the currently active drawing color.  <a href="classglib_1_1_graphics.html#a80c9c2db8bb90e97f2fa8e5b94c1247f">More...</a><br /></td></tr>
<tr class="separator:a80c9c2db8bb90e97f2fa8e5b94c1247f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7acef5fbc49d1dcc126e0aeb7d5fa718"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a7acef5fbc49d1dcc126e0aeb7d5fa718">setFont</a> (<a class="el" href="classglib_1_1_font.html">Font</a> *f)</td></tr>
<tr class="memdesc:a7acef5fbc49d1dcc126e0aeb7d5fa718"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the currently active <a class="el" href="classglib_1_1_font.html">Font</a>.  <a href="classglib_1_1_graphics.html#a7acef5fbc49d1dcc126e0aeb7d5fa718">More...</a><br /></td></tr>
<tr class="separator:a7acef5fbc49d1dcc126e0aeb7d5fa718"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5f291bde6f688dfdbe18240e72265a2"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classglib_1_1_font.html">Font</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#af5f291bde6f688dfdbe18240e72265a2">getFont</a> ()</td></tr>
<tr class="memdesc:af5f291bde6f688dfdbe18240e72265a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the currently active <a class="el" href="classglib_1_1_font.html">Font</a>.  <a href="classglib_1_1_graphics.html#af5f291bde6f688dfdbe18240e72265a2">More...</a><br /></td></tr>
<tr class="separator:af5f291bde6f688dfdbe18240e72265a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2c4ce1332497b8197d2ec1545d546d15"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a2c4ce1332497b8197d2ec1545d546d15">setDefaultFont</a> (unsigned char type)</td></tr>
<tr class="memdesc:a2c4ce1332497b8197d2ec1545d546d15"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the default font to one of the 3 types of default fonts available. These can be modified to the users liking by changing the font files in the resources folder.  <a href="classglib_1_1_graphics.html#a2c4ce1332497b8197d2ec1545d546d15">More...</a><br /></td></tr>
<tr class="separator:a2c4ce1332497b8197d2ec1545d546d15"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6776b379bf2ae4e8e94025543e37639e"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classglib_1_1_font.html">Font</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a6776b379bf2ae4e8e94025543e37639e">getDefaultFont</a> (unsigned char type)</td></tr>
<tr class="memdesc:a6776b379bf2ae4e8e94025543e37639e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns one of the default font specified. These can be modified to the users liking by changing the font files in the resources folder.  <a href="classglib_1_1_graphics.html#a6776b379bf2ae4e8e94025543e37639e">More...</a><br /></td></tr>
<tr class="separator:a6776b379bf2ae4e8e94025543e37639e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac98bf270e947eb0470661b729e946771"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#ac98bf270e947eb0470661b729e946771">setCompositeRule</a> (unsigned char b)</td></tr>
<tr class="memdesc:ac98bf270e947eb0470661b729e946771"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the Porter Duff rule to use for color and alpha blending.  <a href="classglib_1_1_graphics.html#ac98bf270e947eb0470661b729e946771">More...</a><br /></td></tr>
<tr class="separator:ac98bf270e947eb0470661b729e946771"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac12fc361d934857194fdbaf5d998a3b0"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#ac12fc361d934857194fdbaf5d998a3b0">getCompositeRule</a> ()</td></tr>
<tr class="memdesc:ac12fc361d934857194fdbaf5d998a3b0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the Porter Duff rule being used for color and alpha blending.  <a href="classglib_1_1_graphics.html#ac12fc361d934857194fdbaf5d998a3b0">More...</a><br /></td></tr>
<tr class="separator:ac12fc361d934857194fdbaf5d998a3b0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acfb2dd20e827d9ea25a3fd4db620c14f"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#acfb2dd20e827d9ea25a3fd4db620c14f">setBlendMode</a> (unsigned char b)</td></tr>
<tr class="memdesc:acfb2dd20e827d9ea25a3fd4db620c14f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the blend mode to use for color and alpha blending. Currently not implemented.  <a href="classglib_1_1_graphics.html#acfb2dd20e827d9ea25a3fd4db620c14f">More...</a><br /></td></tr>
<tr class="separator:acfb2dd20e827d9ea25a3fd4db620c14f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a24344c6973398d9ecfbf4dfc5b5a376e"><td class="memItemLeft" align="right" valign="top">static unsigned char&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a24344c6973398d9ecfbf4dfc5b5a376e">getBlendMode</a> ()</td></tr>
<tr class="memdesc:a24344c6973398d9ecfbf4dfc5b5a376e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the blend mode used for color and alpha blending. Currently not implemented.  <a href="classglib_1_1_graphics.html#a24344c6973398d9ecfbf4dfc5b5a376e">More...</a><br /></td></tr>
<tr class="separator:a24344c6973398d9ecfbf4dfc5b5a376e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a80340ad2442a27fc96a26a57809aa099"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a80340ad2442a27fc96a26a57809aa099">setFillRule</a> (bool b)</td></tr>
<tr class="memdesc:a80340ad2442a27fc96a26a57809aa099"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets the fill rule to use for drawing polygons. May be removed.  <a href="classglib_1_1_graphics.html#a80340ad2442a27fc96a26a57809aa099">More...</a><br /></td></tr>
<tr class="separator:a80340ad2442a27fc96a26a57809aa099"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1ce5b297148932441cf99806ab72f907"><td class="memItemLeft" align="right" valign="top">static bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a1ce5b297148932441cf99806ab72f907">getFillRule</a> ()</td></tr>
<tr class="memdesc:a1ce5b297148932441cf99806ab72f907"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the fill rule used for drawing polygons. May be removed.  <a href="classglib_1_1_graphics.html#a1ce5b297148932441cf99806ab72f907">More...</a><br /></td></tr>
<tr class="separator:a1ce5b297148932441cf99806ab72f907"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af53845958393815dd2ecf53afd206fd2"><td class="memItemLeft" align="right" valign="top"><a id="af53845958393815dd2ecf53afd206fd2" name="af53845958393815dd2ecf53afd206fd2"></a>
static <a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>crop</b> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, int x1, int y1, int x2, int y2)</td></tr>
<tr class="memdesc:af53845958393815dd2ecf53afd206fd2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new cropped image. Should be deleted when no longer needed. Not currently implemented. <br /></td></tr>
<tr class="separator:af53845958393815dd2ecf53afd206fd2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a13c54e6704a92aa9f5026d3213ed1381"><td class="memItemLeft" align="right" valign="top"><a id="a13c54e6704a92aa9f5026d3213ed1381" name="a13c54e6704a92aa9f5026d3213ed1381"></a>
static <a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td><td class="memItemRight" valign="bottom"><b>crop</b> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, <a class="el" href="classglib_1_1_shape.html">Shape</a> s)</td></tr>
<tr class="memdesc:a13c54e6704a92aa9f5026d3213ed1381"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns a new cropped image. Should be deleted when no longer needed. Not currently implemented. <br /></td></tr>
<tr class="separator:a13c54e6704a92aa9f5026d3213ed1381"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a86997d59f7f0af735d71b173397e4760"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a86997d59f7f0af735d71b173397e4760">replaceColor</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, <a class="el" href="structglib_1_1_color.html">Color</a> oldColor, <a class="el" href="structglib_1_1_color.html">Color</a> newColor, bool ignoreAlpha=false)</td></tr>
<tr class="memdesc:a86997d59f7f0af735d71b173397e4760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replaces the specified color with a new color in the image.  <a href="classglib_1_1_graphics.html#a86997d59f7f0af735d71b173397e4760">More...</a><br /></td></tr>
<tr class="separator:a86997d59f7f0af735d71b173397e4760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a33e5a19ee26114ebba184a76c777f667"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a33e5a19ee26114ebba184a76c777f667">filterOutColor</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, <a class="el" href="structglib_1_1_color.html">Color</a> c1)</td></tr>
<tr class="memdesc:a33e5a19ee26114ebba184a76c777f667"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all colors from the image except the specified color.  <a href="classglib_1_1_graphics.html#a33e5a19ee26114ebba184a76c777f667">More...</a><br /></td></tr>
<tr class="separator:a33e5a19ee26114ebba184a76c777f667"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7d742c17c9a6f33936f8f2646a69a494"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a7d742c17c9a6f33936f8f2646a69a494">filterOutColorRange</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, <a class="el" href="structglib_1_1_color.html">Color</a> c1, <a class="el" href="structglib_1_1_color.html">Color</a> c2)</td></tr>
<tr class="memdesc:a7d742c17c9a6f33936f8f2646a69a494"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes all colors from the image unless they fall within the range between the 2 specified colors.  <a href="classglib_1_1_graphics.html#a7d742c17c9a6f33936f8f2646a69a494">More...</a><br /></td></tr>
<tr class="separator:a7d742c17c9a6f33936f8f2646a69a494"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a637fc88e10dc6a9bd7e45c63f853e454"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a637fc88e10dc6a9bd7e45c63f853e454">convertToColorSpace</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, unsigned char colorSpace)</td></tr>
<tr class="memdesc:a637fc88e10dc6a9bd7e45c63f853e454"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts the pixels in the image to a different color space.  <a href="classglib_1_1_graphics.html#a637fc88e10dc6a9bd7e45c63f853e454">More...</a><br /></td></tr>
<tr class="separator:a637fc88e10dc6a9bd7e45c63f853e454"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2343387605c41f8f8b48af6dd7415109"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a2343387605c41f8f8b48af6dd7415109">boxBlur</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, int boxSize)</td></tr>
<tr class="memdesc:a2343387605c41f8f8b48af6dd7415109"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blurs the image using a simple box blur.  <a href="classglib_1_1_graphics.html#a2343387605c41f8f8b48af6dd7415109">More...</a><br /></td></tr>
<tr class="separator:a2343387605c41f8f8b48af6dd7415109"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a929b33f4df54abd07236ddedb2309643"><td class="memItemLeft" align="right" valign="top"><a id="a929b33f4df54abd07236ddedb2309643" name="a929b33f4df54abd07236ddedb2309643"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>gaussianBlur</b> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, double stdDeviation)</td></tr>
<tr class="memdesc:a929b33f4df54abd07236ddedb2309643"><td class="mdescLeft">&#160;</td><td class="mdescRight">Blurs the image using a guassian blur. Not implemented. <br /></td></tr>
<tr class="separator:a929b33f4df54abd07236ddedb2309643"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9fe359164120d67d2bfe18fbdfd283ae"><td class="memItemLeft" align="right" valign="top"><a id="a9fe359164120d67d2bfe18fbdfd283ae" name="a9fe359164120d67d2bfe18fbdfd283ae"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>uncannyEdgeFilter</b> (<a class="el" href="classglib_1_1_image.html">Image</a> *img)</td></tr>
<tr class="memdesc:a9fe359164120d67d2bfe18fbdfd283ae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies an uncanny edge filter to the image. Not implemented. <br /></td></tr>
<tr class="separator:a9fe359164120d67d2bfe18fbdfd283ae"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5f1c30d88cc9c769df2a94a50cca77d0"><td class="memItemLeft" align="right" valign="top"><a id="a5f1c30d88cc9c769df2a94a50cca77d0" name="a5f1c30d88cc9c769df2a94a50cca77d0"></a>
static void&#160;</td><td class="memItemRight" valign="bottom"><b>sobelEdgeFilter</b> (<a class="el" href="classglib_1_1_image.html">Image</a> *img)</td></tr>
<tr class="memdesc:a5f1c30d88cc9c769df2a94a50cca77d0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Applies a sobel edge filter to the image. Not implemented. <br /></td></tr>
<tr class="separator:a5f1c30d88cc9c769df2a94a50cca77d0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af19b0285b5dfd24b40c31b9b157b4f54"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; std::vector&lt; <a class="el" href="classglib_1_1_vec2f.html">Vec2f</a> &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#af19b0285b5dfd24b40c31b9b157b4f54">calculateGradient</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, unsigned char type)</td></tr>
<tr class="memdesc:af19b0285b5dfd24b40c31b9b157b4f54"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculates the gradient of the specified color channel using central differences.  <a href="classglib_1_1_graphics.html#af19b0285b5dfd24b40c31b9b157b4f54">More...</a><br /></td></tr>
<tr class="separator:af19b0285b5dfd24b40c31b9b157b4f54"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9d3c0a8ffbfec69b8977bf20ff089be"><td class="memItemLeft" align="right" valign="top">static void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#ac9d3c0a8ffbfec69b8977bf20ff089be">ditherImage</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, unsigned char method=THRESHOLD)</td></tr>
<tr class="memdesc:ac9d3c0a8ffbfec69b8977bf20ff089be"><td class="mdescLeft">&#160;</td><td class="mdescRight">Dithers the image using either Bayer dithering or Floyd Steinburg dithering. Can also just enforce the palette. The image must have a palette set to use this method.  <a href="classglib_1_1_graphics.html#ac9d3c0a8ffbfec69b8977bf20ff089be">More...</a><br /></td></tr>
<tr class="separator:ac9d3c0a8ffbfec69b8977bf20ff089be"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9adc4597bd336fc59e7fd5d78a2d572c"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_graphics.html#a9adc4597bd336fc59e7fd5d78a2d572c">scaleImage</a> (<a class="el" href="classglib_1_1_image.html">Image</a> *img, double xScale, double yScale, unsigned char filterMethod=NEAREST_NEIGHBOR_FILTER)</td></tr>
<tr class="memdesc:a9adc4597bd336fc59e7fd5d78a2d572c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Scales an image using the specified filter method and returns a new image. That new image should be deleted when no longer needed.  <a href="classglib_1_1_graphics.html#a9adc4597bd336fc59e7fd5d78a2d572c">More...</a><br /></td></tr>
<tr class="separator:a9adc4597bd336fc59e7fd5d78a2d572c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a63b33a08b5bcea856e3f17ecc8e0a9ad"><td class="memItemLeft" align="right" valign="top"><a id="a63b33a08b5bcea856e3f17ecc8e0a9ad" name="a63b33a08b5bcea856e3f17ecc8e0a9ad"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>NO_COMPOSITE</b> = 255</td></tr>
<tr class="separator:a63b33a08b5bcea856e3f17ecc8e0a9ad"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9c1b50e4684106593b842d97631e83c2"><td class="memItemLeft" align="right" valign="top"><a id="a9c1b50e4684106593b842d97631e83c2" name="a9c1b50e4684106593b842d97631e83c2"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_CLEAR</b> = 0</td></tr>
<tr class="separator:a9c1b50e4684106593b842d97631e83c2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4f9d6776b83a99824012da7b0225512"><td class="memItemLeft" align="right" valign="top"><a id="aa4f9d6776b83a99824012da7b0225512" name="aa4f9d6776b83a99824012da7b0225512"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_COPY</b> = 1</td></tr>
<tr class="separator:aa4f9d6776b83a99824012da7b0225512"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaec8c2ea17532e2cf5675d2de460c405"><td class="memItemLeft" align="right" valign="top"><a id="aaec8c2ea17532e2cf5675d2de460c405" name="aaec8c2ea17532e2cf5675d2de460c405"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_DEST</b> = 2</td></tr>
<tr class="separator:aaec8c2ea17532e2cf5675d2de460c405"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4e89d4bd42b19ec37c3d2e75293f2c4c"><td class="memItemLeft" align="right" valign="top"><a id="a4e89d4bd42b19ec37c3d2e75293f2c4c" name="a4e89d4bd42b19ec37c3d2e75293f2c4c"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_SRC_OVER</b> = 3</td></tr>
<tr class="separator:a4e89d4bd42b19ec37c3d2e75293f2c4c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2bf6287f6ddddb95025d18fecc65820d"><td class="memItemLeft" align="right" valign="top"><a id="a2bf6287f6ddddb95025d18fecc65820d" name="a2bf6287f6ddddb95025d18fecc65820d"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_DEST_OVER</b> = 4</td></tr>
<tr class="separator:a2bf6287f6ddddb95025d18fecc65820d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a19290663b5a874694077595e6d17b657"><td class="memItemLeft" align="right" valign="top"><a id="a19290663b5a874694077595e6d17b657" name="a19290663b5a874694077595e6d17b657"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_SRC_IN</b> = 5</td></tr>
<tr class="separator:a19290663b5a874694077595e6d17b657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6f4098abf8f3f8318b7211288d33974"><td class="memItemLeft" align="right" valign="top"><a id="af6f4098abf8f3f8318b7211288d33974" name="af6f4098abf8f3f8318b7211288d33974"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_DEST_IN</b> = 6</td></tr>
<tr class="separator:af6f4098abf8f3f8318b7211288d33974"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad6a680b8fc71d9cbccdfa74ecb119f91"><td class="memItemLeft" align="right" valign="top"><a id="ad6a680b8fc71d9cbccdfa74ecb119f91" name="ad6a680b8fc71d9cbccdfa74ecb119f91"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_SRC_OUT</b> = 7</td></tr>
<tr class="separator:ad6a680b8fc71d9cbccdfa74ecb119f91"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d5453d8f80bb1eb717e93d2dfd366f6"><td class="memItemLeft" align="right" valign="top"><a id="a9d5453d8f80bb1eb717e93d2dfd366f6" name="a9d5453d8f80bb1eb717e93d2dfd366f6"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_DEST_OUT</b> = 8</td></tr>
<tr class="separator:a9d5453d8f80bb1eb717e93d2dfd366f6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5ac634896b5bdced5beab79dd2c555b1"><td class="memItemLeft" align="right" valign="top"><a id="a5ac634896b5bdced5beab79dd2c555b1" name="a5ac634896b5bdced5beab79dd2c555b1"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_SRC_ATOP</b> = 9</td></tr>
<tr class="separator:a5ac634896b5bdced5beab79dd2c555b1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adb3caaeea2bd81782ab0dd23c348ea5e"><td class="memItemLeft" align="right" valign="top"><a id="adb3caaeea2bd81782ab0dd23c348ea5e" name="adb3caaeea2bd81782ab0dd23c348ea5e"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_DEST_ATOP</b> = 10</td></tr>
<tr class="separator:adb3caaeea2bd81782ab0dd23c348ea5e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad932dea8f33967f099a3ca1627d92989"><td class="memItemLeft" align="right" valign="top"><a id="ad932dea8f33967f099a3ca1627d92989" name="ad932dea8f33967f099a3ca1627d92989"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_XOR</b> = 11</td></tr>
<tr class="separator:ad932dea8f33967f099a3ca1627d92989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a54e0068271b3a69cb28a3ec14ec93803"><td class="memItemLeft" align="right" valign="top"><a id="a54e0068271b3a69cb28a3ec14ec93803" name="a54e0068271b3a69cb28a3ec14ec93803"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>COMPOSITE_LIGHTER</b> = 12</td></tr>
<tr class="separator:a54e0068271b3a69cb28a3ec14ec93803"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58378db75500423f6cd471abb1fcd7d6"><td class="memItemLeft" align="right" valign="top"><a id="a58378db75500423f6cd471abb1fcd7d6" name="a58378db75500423f6cd471abb1fcd7d6"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>FILL_EVEN_ODD</b> = 0</td></tr>
<tr class="separator:a58378db75500423f6cd471abb1fcd7d6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a57ea6be8765c2711271d6d70906766cd"><td class="memItemLeft" align="right" valign="top"><a id="a57ea6be8765c2711271d6d70906766cd" name="a57ea6be8765c2711271d6d70906766cd"></a>
static const bool&#160;</td><td class="memItemRight" valign="bottom"><b>FILL_NON_ZERO</b> = 1</td></tr>
<tr class="separator:a57ea6be8765c2711271d6d70906766cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1cfb565f9d04623b02c1a6960d4964a5"><td class="memItemLeft" align="right" valign="top"><a id="a1cfb565f9d04623b02c1a6960d4964a5" name="a1cfb565f9d04623b02c1a6960d4964a5"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>BLEND_NORMAL</b> = 0</td></tr>
<tr class="separator:a1cfb565f9d04623b02c1a6960d4964a5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5fdecaa842bd6000740bdbdd5d3295f3"><td class="memItemLeft" align="right" valign="top"><a id="a5fdecaa842bd6000740bdbdd5d3295f3" name="a5fdecaa842bd6000740bdbdd5d3295f3"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>BLEND_MULT</b> = 1</td></tr>
<tr class="separator:a5fdecaa842bd6000740bdbdd5d3295f3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab5c17842094e17c1aacf82f28b0950f7"><td class="memItemLeft" align="right" valign="top"><a id="ab5c17842094e17c1aacf82f28b0950f7" name="ab5c17842094e17c1aacf82f28b0950f7"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>BLEND_SCREEN</b> = 2</td></tr>
<tr class="separator:ab5c17842094e17c1aacf82f28b0950f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac31ddc2ba9702e31615d560626ed911b"><td class="memItemLeft" align="right" valign="top"><a id="ac31ddc2ba9702e31615d560626ed911b" name="ac31ddc2ba9702e31615d560626ed911b"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>NORMAL_FONT</b> = 0</td></tr>
<tr class="separator:ac31ddc2ba9702e31615d560626ed911b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade2a5e52b664d4b0202c840f463a50b7"><td class="memItemLeft" align="right" valign="top"><a id="ade2a5e52b664d4b0202c840f463a50b7" name="ade2a5e52b664d4b0202c840f463a50b7"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>MEDIUM_FONT</b> = 1</td></tr>
<tr class="separator:ade2a5e52b664d4b0202c840f463a50b7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af70855a05551076846f44c412c8c232b"><td class="memItemLeft" align="right" valign="top"><a id="af70855a05551076846f44c412c8c232b" name="af70855a05551076846f44c412c8c232b"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>LARGE_FONT</b> = 2</td></tr>
<tr class="separator:af70855a05551076846f44c412c8c232b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9a16f1c1c5b74fe9e7cb7229e59469b6"><td class="memItemLeft" align="right" valign="top"><a id="a9a16f1c1c5b74fe9e7cb7229e59469b6" name="a9a16f1c1c5b74fe9e7cb7229e59469b6"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>THRESHOLD</b> = 0</td></tr>
<tr class="separator:a9a16f1c1c5b74fe9e7cb7229e59469b6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a75163ade7fae32f3364a6f7a33bd744b"><td class="memItemLeft" align="right" valign="top"><a id="a75163ade7fae32f3364a6f7a33bd744b" name="a75163ade7fae32f3364a6f7a33bd744b"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>ORDERED_DITHER_BAYER</b> = 1</td></tr>
<tr class="separator:a75163ade7fae32f3364a6f7a33bd744b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3e10a64c454abb676ebd0695a0a5bd5"><td class="memItemLeft" align="right" valign="top"><a id="ac3e10a64c454abb676ebd0695a0a5bd5" name="ac3e10a64c454abb676ebd0695a0a5bd5"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>FLOYD_DITHER</b> = 2</td></tr>
<tr class="separator:ac3e10a64c454abb676ebd0695a0a5bd5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a676de516354ec7f8f25b7691f05b23e6"><td class="memItemLeft" align="right" valign="top"><a id="a676de516354ec7f8f25b7691f05b23e6" name="a676de516354ec7f8f25b7691f05b23e6"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>NEAREST_NEIGHBOR_FILTER</b> = 0</td></tr>
<tr class="separator:a676de516354ec7f8f25b7691f05b23e6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aacf4b7f434c276ea78a1c6746a6a9de8"><td class="memItemLeft" align="right" valign="top"><a id="aacf4b7f434c276ea78a1c6746a6a9de8" name="aacf4b7f434c276ea78a1c6746a6a9de8"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>BILINEAR_FILTER</b> = 1</td></tr>
<tr class="separator:aacf4b7f434c276ea78a1c6746a6a9de8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65e4af5cdc0aefe064659db050fbb7e5"><td class="memItemLeft" align="right" valign="top"><a id="a65e4af5cdc0aefe064659db050fbb7e5" name="a65e4af5cdc0aefe064659db050fbb7e5"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>BICUBIC_FILTER</b> = 2</td></tr>
<tr class="separator:a65e4af5cdc0aefe064659db050fbb7e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2ace6ff422d7a0e41a148de1f158810d"><td class="memItemLeft" align="right" valign="top"><a id="a2ace6ff422d7a0e41a148de1f158810d" name="a2ace6ff422d7a0e41a148de1f158810d"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>RED_CHANNEL</b> = 0</td></tr>
<tr class="separator:a2ace6ff422d7a0e41a148de1f158810d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5c76dae2e3f939fe234ab263ce1a5efc"><td class="memItemLeft" align="right" valign="top"><a id="a5c76dae2e3f939fe234ab263ce1a5efc" name="a5c76dae2e3f939fe234ab263ce1a5efc"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>GREEN_CHANNEL</b> = 1</td></tr>
<tr class="separator:a5c76dae2e3f939fe234ab263ce1a5efc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5338677bc3be21f19e7e93010149a491"><td class="memItemLeft" align="right" valign="top"><a id="a5338677bc3be21f19e7e93010149a491" name="a5338677bc3be21f19e7e93010149a491"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>BLUE_CHANNEL</b> = 2</td></tr>
<tr class="separator:a5338677bc3be21f19e7e93010149a491"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc558e1aa9deb7786a98b3aaff82aeaf"><td class="memItemLeft" align="right" valign="top"><a id="abc558e1aa9deb7786a98b3aaff82aeaf" name="abc558e1aa9deb7786a98b3aaff82aeaf"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>ALPHA_CHANNEL</b> = 3</td></tr>
<tr class="separator:abc558e1aa9deb7786a98b3aaff82aeaf"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="ab3606cf0cc23415b750b84696be9d2ca" name="ab3606cf0cc23415b750b84696be9d2ca"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab3606cf0cc23415b750b84696be9d2ca">&#9670;&nbsp;</a></span>blend()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structglib_1_1_color.html">Color</a> glib::Graphics::blend </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>dest</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blends 2 colors using Porter Duff rules. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The source color. </td></tr>
    <tr><td class="paramname">dest</td><td>The destination color. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structglib_1_1_color.html">Color</a> </dd></dl>

</div>
</div>
<a id="a2343387605c41f8f8b48af6dd7415109" name="a2343387605c41f8f8b48af6dd7415109"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2343387605c41f8f8b48af6dd7415109">&#9670;&nbsp;</a></span>boxBlur()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::boxBlur </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>boxSize</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Blurs the image using a simple box blur. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to operate on. </td></tr>
    <tr><td class="paramname">boxSize</td><td>The size of the box to use for bluring. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af19b0285b5dfd24b40c31b9b157b4f54" name="af19b0285b5dfd24b40c31b9b157b4f54"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af19b0285b5dfd24b40c31b9b157b4f54">&#9670;&nbsp;</a></span>calculateGradient()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; std::vector&lt; <a class="el" href="classglib_1_1_vec2f.html">Vec2f</a> &gt; &gt; glib::Graphics::calculateGradient </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>type</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Calculates the gradient of the specified color channel using central differences. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to operate on. </td></tr>
    <tr><td class="paramname">type</td><td>Must be one of the following types. RED_CHANNEL GREEN_CHANNEL BLUE_CHANNEL ALPHA_CHANNEL </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;std::vector&lt;Vec2f&gt;&gt; Returns a 2D vector of <a class="el" href="classglib_1_1_vec2f.html">Vec2f</a> where each <a class="el" href="classglib_1_1_vec2f.html">Vec2f</a> stores the gradient at that point. </dd></dl>

</div>
</div>
<a id="a7d860db215c5227ba1703eb93f9bbc4e" name="a7d860db215c5227ba1703eb93f9bbc4e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d860db215c5227ba1703eb93f9bbc4e">&#9670;&nbsp;</a></span>clearImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::clearImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Clears the specified Image* to the draw color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">surf</td><td>If set to nullptr, no error is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a637fc88e10dc6a9bd7e45c63f853e454" name="a637fc88e10dc6a9bd7e45c63f853e454"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a637fc88e10dc6a9bd7e45c63f853e454">&#9670;&nbsp;</a></span>convertToColorSpace()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::convertToColorSpace </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>colorSpace</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Converts the pixels in the image to a different color space. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to operate on. </td></tr>
    <tr><td class="paramname">colorSpace</td><td>One of the operations defined in <a class="el" href="classglib_1_1_color_space_converter.html">ColorSpaceConverter</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac9d3c0a8ffbfec69b8977bf20ff089be" name="ac9d3c0a8ffbfec69b8977bf20ff089be"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac9d3c0a8ffbfec69b8977bf20ff089be">&#9670;&nbsp;</a></span>ditherImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::ditherImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>method</em> = <code>THRESHOLD</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Dithers the image using either Bayer dithering or Floyd Steinburg dithering. Can also just enforce the palette. The image must have a palette set to use this method. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to operate on. Must have the palette set. </td></tr>
    <tr><td class="paramname">method</td><td>The dithering method to use. Valid options are: ORDERED_DITHER_BAYER FLOYD_DITHER THRESHOLD If set to THRESHOLD, the image will just have its palette enforced. Default value is THRESHOLD. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf513c3dc5c58d0791079181e9a37cd7" name="aaf513c3dc5c58d0791079181e9a37cd7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf513c3dc5c58d0791079181e9a37cd7">&#9670;&nbsp;</a></span>drawCircle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawCircle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>radius</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a circle using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The center x location of the circle. </td></tr>
    <tr><td class="paramname">y</td><td>The center y location of the circle </td></tr>
    <tr><td class="paramname">radius</td><td>The radius of the circle. </td></tr>
    <tr><td class="paramname">outline</td><td>Controls whether only the outline of the circle should be drawn. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw the circle onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aa796cf0e60cccf00bfd6db7265034291" name="aa796cf0e60cccf00bfd6db7265034291"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa796cf0e60cccf00bfd6db7265034291">&#9670;&nbsp;</a></span>drawImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an <a class="el" href="classglib_1_1_image.html">Image</a>. The active color has no influence. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to draw. </td></tr>
    <tr><td class="paramname">x</td><td>The x location to draw at. </td></tr>
    <tr><td class="paramname">y</td><td>The y location to draw at. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a1a1475c9ad7f98719cd39ed5ab6c9ebc" name="a1a1475c9ad7f98719cd39ed5ab6c9ebc"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1a1475c9ad7f98719cd39ed5ab6c9ebc">&#9670;&nbsp;</a></span>drawLine()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawLine </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a <a class="el" href="classglib_1_1_line.html">Line</a> using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x location of the line. </td></tr>
    <tr><td class="paramname">y</td><td>The y location of the line </td></tr>
    <tr><td class="paramname">x2</td><td>The 2nd x location of the line. </td></tr>
    <tr><td class="paramname">y2</td><td>The 2nd y location of the line. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw the line onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0646616a90f27f2e0408bb45711d25ae" name="a0646616a90f27f2e0408bb45711d25ae"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0646616a90f27f2e0408bb45711d25ae">&#9670;&nbsp;</a></span>drawModel()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawModel </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_model.html">Model</a> *&#160;</td>
          <td class="paramname"><em>model</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a model using the active draw color or texture. Follows OpenGL drawing. Only 2D shapes are supported. Expects position, and if desired texture, to be defined in the model. Expects position and texture to be Model::TYPE_VEC2. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">model</td><td>The model to draw. </td></tr>
    <tr><td class="paramname">texture</td><td>The texture to use if desired. If the model has texture coordinates, this can not be nullptr. Otherwise, it can be nullptr. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad7ee57c195787298c8a0a2413ed49a38" name="ad7ee57c195787298c8a0a2413ed49a38"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad7ee57c195787298c8a0a2413ed49a38">&#9670;&nbsp;</a></span>drawPixel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawPixel </td>
          <td>(</td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a pixel to the specified image using Porter Duff rules. This function can draw up to 4 different pixels due to the specified point not directly lining up with the pixel grid. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x location of the pixel. </td></tr>
    <tr><td class="paramname">y</td><td>The y location of the pixel. </td></tr>
    <tr><td class="paramname">c</td><td>The color of the pixel. </td></tr>
    <tr><td class="paramname">surf</td><td>If set to nullptr, no error is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2ede68aed7abda6e9ad9b927170aa842" name="a2ede68aed7abda6e9ad9b927170aa842"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2ede68aed7abda6e9ad9b927170aa842">&#9670;&nbsp;</a></span>drawPixel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawPixel </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>c</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a pixel to the specified image using Porter Duff rules. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x location of the pixel. </td></tr>
    <tr><td class="paramname">y</td><td>The y location of the pixel. </td></tr>
    <tr><td class="paramname">c</td><td>The color of the pixel. </td></tr>
    <tr><td class="paramname">surf</td><td>If set to nullptr, no error is thrown. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af1c8f49d1eb8a170b8ca12567ca011a0" name="af1c8f49d1eb8a170b8ca12567ca011a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af1c8f49d1eb8a170b8ca12567ca011a0">&#9670;&nbsp;</a></span>drawPolygon()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawPolygon </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_vec2f.html">Vec2f</a> *&#160;</td>
          <td class="paramname"><em>points</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a polygon using the active draw color. Is affected by the current fill rule. May be removed as VectorGraphics accomplishes the same thing but will have more options. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">points</td><td>An array of points for the polygon. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the array. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a4b7a04d7634bd263235cefb7433b5b83" name="a4b7a04d7634bd263235cefb7433b5b83"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4b7a04d7634bd263235cefb7433b5b83">&#9670;&nbsp;</a></span>drawRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawRect </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a rectangle using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x location of the rectangle. </td></tr>
    <tr><td class="paramname">y</td><td>The y location of the rectangle </td></tr>
    <tr><td class="paramname">x2</td><td>The 2nd x location of the rectangle. </td></tr>
    <tr><td class="paramname">y2</td><td>The 2nd y location of the rectangle. </td></tr>
    <tr><td class="paramname">outline</td><td>Controls whether only the outline of the rectangle should be drawn. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw the rectangle onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adfcad2373a8083e8b90fa82f28c3413d" name="adfcad2373a8083e8b90fa82f28c3413d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adfcad2373a8083e8b90fa82f28c3413d">&#9670;&nbsp;</a></span>drawSprite()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawSprite </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws an <a class="el" href="classglib_1_1_image.html">Image</a> that is modified by the active drawing color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to draw. </td></tr>
    <tr><td class="paramname">x</td><td>The x location to draw at. </td></tr>
    <tr><td class="paramname">y</td><td>The y location to draw at. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acc89b72431ad7ff7933397b8ac354902" name="acc89b72431ad7ff7933397b8ac354902"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acc89b72431ad7ff7933397b8ac354902">&#9670;&nbsp;</a></span>drawSpritePart()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawSpritePart </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imgX</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imgY</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imgW</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>imgH</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a part of an <a class="el" href="classglib_1_1_image.html">Image</a> that will be modified by the active drawing color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to draw. </td></tr>
    <tr><td class="paramname">x</td><td>The x location to draw at. </td></tr>
    <tr><td class="paramname">y</td><td>The y location to draw at. </td></tr>
    <tr><td class="paramname">imgX</td><td>The starting x position of the part of the texture image we are drawing. </td></tr>
    <tr><td class="paramname">imgY</td><td>The starting y position of the part of the texture image we are drawing. </td></tr>
    <tr><td class="paramname">imgW</td><td>The width of the part of the texture image we are drawing. </td></tr>
    <tr><td class="paramname">imgH</td><td>The height of the part of the texture image we are drawing. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6828073d7be88610fa338811e9a7d5fe" name="a6828073d7be88610fa338811e9a7d5fe"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6828073d7be88610fa338811e9a7d5fe">&#9670;&nbsp;</a></span>drawText()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawText </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the specified text using the active font. It is affected by the active drawing color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The text to draw. </td></tr>
    <tr><td class="paramname">x</td><td>The x location to draw at. </td></tr>
    <tr><td class="paramname">y</td><td>The y location to draw at. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ab1c69033fc237648dc82d64a0712bbd0" name="ab1c69033fc237648dc82d64a0712bbd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab1c69033fc237648dc82d64a0712bbd0">&#9670;&nbsp;</a></span>drawTextLimits()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawTextLimits </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>str</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxWidth</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxHeight</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>useLineBreak</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws the specified text using the active font. It is affected by the active drawing color. Adds additional limits such as the maximum width and maximum height. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">str</td><td>The text to draw. </td></tr>
    <tr><td class="paramname">x</td><td>The x location to draw at. </td></tr>
    <tr><td class="paramname">y</td><td>The y location to draw at. </td></tr>
    <tr><td class="paramname">maxWidth</td><td>The maximum width that is allowed before a line break occurs. </td></tr>
    <tr><td class="paramname">maxHeight</td><td>The maximum height that is allowed. </td></tr>
    <tr><td class="paramname">useLineBreaks</td><td>If set to false, drawing stops if the text hits the maximum width. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adda98ffe0d32fac75c82c79835b31643" name="adda98ffe0d32fac75c82c79835b31643"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adda98ffe0d32fac75c82c79835b31643">&#9670;&nbsp;</a></span>drawTexturedTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawTexturedTriangle </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_vec4f.html">Vec4f</a>&#160;</td>
          <td class="paramname"><em>p1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_vec4f.html">Vec4f</a>&#160;</td>
          <td class="paramname"><em>p2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_vec4f.html">Vec4f</a>&#160;</td>
          <td class="paramname"><em>p3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>texture</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a triangle using the specified image. Is not affected by the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<p >Uses <a class="el" href="classglib_1_1_vec4f.html">Vec4f</a> where the x,y specify the point on the triangle and z,w specify texture coordinates between [0, 1] </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">p1</td><td>The 1st location of the triangle along with it's texture coordinates. </td></tr>
    <tr><td class="paramname">p2</td><td>The 2nd location of the triangle along with it's texture coordinates. </td></tr>
    <tr><td class="paramname">p3</td><td>The 3rd location of the triangle along with it's texture coordinates. </td></tr>
    <tr><td class="paramname">texture</td><td>The texture to map onto the triangle. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw the triangle onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="aaf6e7568e21d0f18e83c1e47abef2a28" name="aaf6e7568e21d0f18e83c1e47abef2a28"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aaf6e7568e21d0f18e83c1e47abef2a28">&#9670;&nbsp;</a></span>drawTriangle()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::drawTriangle </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y2</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>x3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>y3</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>outline</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>surf</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Draws a triangle using the active color. If OPTI is defined as 1, SSE instructions are used. If OPTI is defined as 2, AVX instructions are used. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>The x location of the triangle. </td></tr>
    <tr><td class="paramname">y</td><td>The y location of the triangle </td></tr>
    <tr><td class="paramname">x2</td><td>The 2nd x location of the triangle. </td></tr>
    <tr><td class="paramname">y2</td><td>The 2nd y location of the triangle. </td></tr>
    <tr><td class="paramname">x3</td><td>The 3rd x location of the triangle. </td></tr>
    <tr><td class="paramname">y3</td><td>The 3rd y location of the triangle. </td></tr>
    <tr><td class="paramname">outline</td><td>Controls whether only the outline of the triangle should be drawn. </td></tr>
    <tr><td class="paramname">surf</td><td>The image to draw the triangle onto. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a33e5a19ee26114ebba184a76c777f667" name="a33e5a19ee26114ebba184a76c777f667"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a33e5a19ee26114ebba184a76c777f667">&#9670;&nbsp;</a></span>filterOutColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::filterOutColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>c1</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all colors from the image except the specified color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to operate on. </td></tr>
    <tr><td class="paramname">c1</td><td>The color to keep. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7d742c17c9a6f33936f8f2646a69a494" name="a7d742c17c9a6f33936f8f2646a69a494"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7d742c17c9a6f33936f8f2646a69a494">&#9670;&nbsp;</a></span>filterOutColorRange()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::filterOutColorRange </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>c1</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>c2</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Removes all colors from the image unless they fall within the range between the 2 specified colors. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to operate on. </td></tr>
    <tr><td class="paramname">c1</td><td>The start of the color range. </td></tr>
    <tr><td class="paramname">c2</td><td>The end of the color range. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a24344c6973398d9ecfbf4dfc5b5a376e" name="a24344c6973398d9ecfbf4dfc5b5a376e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a24344c6973398d9ecfbf4dfc5b5a376e">&#9670;&nbsp;</a></span>getBlendMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char glib::Graphics::getBlendMode </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the blend mode used for color and alpha blending. Currently not implemented. </p>
<dl class="section return"><dt>Returns</dt><dd>unsigned char </dd></dl>

</div>
</div>
<a id="a44ceda2ca0404aa740fd302225965e82" name="a44ceda2ca0404aa740fd302225965e82"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a44ceda2ca0404aa740fd302225965e82">&#9670;&nbsp;</a></span>getClippingRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classglib_1_1_box2_d.html">Box2D</a> glib::Graphics::getClippingRect </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the clipping rectangle currently used. Anything outside of the rectangle is not drawn. </p>
<dl class="section return"><dt>Returns</dt><dd>Box2d </dd></dl>

</div>
</div>
<a id="a80c9c2db8bb90e97f2fa8e5b94c1247f" name="a80c9c2db8bb90e97f2fa8e5b94c1247f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80c9c2db8bb90e97f2fa8e5b94c1247f">&#9670;&nbsp;</a></span>getColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structglib_1_1_color.html">Color</a> glib::Graphics::getColor </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the currently active drawing color. </p>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structglib_1_1_color.html">Color</a> </dd></dl>

</div>
</div>
<a id="ac12fc361d934857194fdbaf5d998a3b0" name="ac12fc361d934857194fdbaf5d998a3b0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac12fc361d934857194fdbaf5d998a3b0">&#9670;&nbsp;</a></span>getCompositeRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned char glib::Graphics::getCompositeRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the Porter Duff rule being used for color and alpha blending. </p>
<dl class="section return"><dt>Returns</dt><dd>unsigned char </dd></dl>

</div>
</div>
<a id="a6776b379bf2ae4e8e94025543e37639e" name="a6776b379bf2ae4e8e94025543e37639e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6776b379bf2ae4e8e94025543e37639e">&#9670;&nbsp;</a></span>getDefaultFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classglib_1_1_font.html">Font</a> * glib::Graphics::getDefaultFont </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns one of the default font specified. These can be modified to the users liking by changing the font files in the resources folder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Must be one of the following constants. NORMAL_FONT MEDIUM_FONT LARGE_FONT </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Font* May return nullptr if the font was not loaded. </dd></dl>

</div>
</div>
<a id="a1ce5b297148932441cf99806ab72f907" name="a1ce5b297148932441cf99806ab72f907"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1ce5b297148932441cf99806ab72f907">&#9670;&nbsp;</a></span>getFillRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static bool glib::Graphics::getFillRule </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the fill rule used for drawing polygons. May be removed. </p>
<dl class="section return"><dt>Returns</dt><dd>b </dd></dl>

</div>
</div>
<a id="af5f291bde6f688dfdbe18240e72265a2" name="af5f291bde6f688dfdbe18240e72265a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5f291bde6f688dfdbe18240e72265a2">&#9670;&nbsp;</a></span>getFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classglib_1_1_font.html">Font</a> * glib::Graphics::getFont </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Returns the currently active <a class="el" href="classglib_1_1_font.html">Font</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>Font* If the active font is nullptr, the currently active default font is returned. </dd></dl>

</div>
</div>
<a id="a9ee604e5ee9e0dcfe89d3af935b6d080" name="a9ee604e5ee9e0dcfe89d3af935b6d080"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9ee604e5ee9e0dcfe89d3af935b6d080">&#9670;&nbsp;</a></span>lerp()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="structglib_1_1_color.html">Color</a> glib::Graphics::lerp </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>src</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>dest</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>lerpVal</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Linearly blends 2 colors together. At value 0, src is the output color. At value 1, dest is the output color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">src</td><td>The start color. </td></tr>
    <tr><td class="paramname">dest</td><td>The end color. </td></tr>
    <tr><td class="paramname">lerpVal</td><td>The blending value. Should be between [0, 1] </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><a class="el" href="structglib_1_1_color.html">Color</a> Returns the blended color. </dd></dl>

</div>
</div>
<a id="a86997d59f7f0af735d71b173397e4760" name="a86997d59f7f0af735d71b173397e4760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a86997d59f7f0af735d71b173397e4760">&#9670;&nbsp;</a></span>replaceColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::replaceColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>oldColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>newColor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>ignoreAlpha</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Replaces the specified color with a new color in the image. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to operate on. </td></tr>
    <tr><td class="paramname">oldColor</td><td>The color to replace. </td></tr>
    <tr><td class="paramname">newColor</td><td>The new color to be used. </td></tr>
    <tr><td class="paramname">ignoreAlpha</td><td>Whether to ignore alpha when checking to replace. Note that the alpha will be set to the new colors alpha. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a9adc4597bd336fc59e7fd5d78a2d572c" name="a9adc4597bd336fc59e7fd5d78a2d572c"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a9adc4597bd336fc59e7fd5d78a2d572c">&#9670;&nbsp;</a></span>scaleImage()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classglib_1_1_image.html">Image</a> * glib::Graphics::scaleImage </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_image.html">Image</a> *&#160;</td>
          <td class="paramname"><em>img</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>xScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>yScale</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>filterMethod</em> = <code>NEAREST_NEIGHBOR_FILTER</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Scales an image using the specified filter method and returns a new image. That new image should be deleted when no longer needed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">img</td><td>The image to scale. </td></tr>
    <tr><td class="paramname">xScale</td><td>The x scale value. Must be a positive number. </td></tr>
    <tr><td class="paramname">yScale</td><td>The y scale value. Must be a positive number. </td></tr>
    <tr><td class="paramname">filterMethod</td><td>Must be one of the following values: NEAREST_NEIGHBOR_FILTER BILINEAR_FILTER BICUBIC_FILTER The default is NEAREST_NEIGHBOR_FILTER </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="acfb2dd20e827d9ea25a3fd4db620c14f" name="acfb2dd20e827d9ea25a3fd4db620c14f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acfb2dd20e827d9ea25a3fd4db620c14f">&#9670;&nbsp;</a></span>setBlendMode()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::setBlendMode </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the blend mode to use for color and alpha blending. Currently not implemented. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Must be one of the blend mode constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af6a66498b02ba6afa2589fbe4fa88a33" name="af6a66498b02ba6afa2589fbe4fa88a33"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af6a66498b02ba6afa2589fbe4fa88a33">&#9670;&nbsp;</a></span>setClippingRect()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::setClippingRect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_box2_d.html">Box2D</a>&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets a rectangle where drawing will be allowed for the following drawing operations. Anything outside of the rectangle is not drawn. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>The box to use. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7743fdbb26b410deb9cb665dd5869c15" name="a7743fdbb26b410deb9cb665dd5869c15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7743fdbb26b410deb9cb665dd5869c15">&#9670;&nbsp;</a></span>setColor()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::setColor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="structglib_1_1_color.html">Color</a>&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the currently active drawing color. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">c</td><td></td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac98bf270e947eb0470661b729e946771" name="ac98bf270e947eb0470661b729e946771"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac98bf270e947eb0470661b729e946771">&#9670;&nbsp;</a></span>setCompositeRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::setCompositeRule </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the Porter Duff rule to use for color and alpha blending. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>Must be one of the composite constants. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2c4ce1332497b8197d2ec1545d546d15" name="a2c4ce1332497b8197d2ec1545d546d15"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2c4ce1332497b8197d2ec1545d546d15">&#9670;&nbsp;</a></span>setDefaultFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::setDefaultFont </td>
          <td>(</td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>type</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the default font to one of the 3 types of default fonts available. These can be modified to the users liking by changing the font files in the resources folder. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>Must be one of the following constants. NORMAL_FONT MEDIUM_FONT LARGE_FONT </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a80340ad2442a27fc96a26a57809aa099" name="a80340ad2442a27fc96a26a57809aa099"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a80340ad2442a27fc96a26a57809aa099">&#9670;&nbsp;</a></span>setFillRule()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::setFillRule </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>b</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the fill rule to use for drawing polygons. May be removed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">b</td><td>valid options are FILL_EVEN_ODD or FILL_NON_ZERO </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7acef5fbc49d1dcc126e0aeb7d5fa718" name="a7acef5fbc49d1dcc126e0aeb7d5fa718"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7acef5fbc49d1dcc126e0aeb7d5fa718">&#9670;&nbsp;</a></span>setFont()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static void glib::Graphics::setFont </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classglib_1_1_font.html">Font</a> *&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Sets the currently active <a class="el" href="classglib_1_1_font.html">Font</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">f</td><td>Can be nullptr. If nullptr, one of the default fonts will be used. </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="_graphics_8h_source.html">Graphics.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.2"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>GLIB: glib::Compression Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">GLIB<span id="projectnumber">&#160;1.0</span>
   </div>
   <div id="projectbrief">A simple C++ library for general software development.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.2 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search",'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><b>glib</b></li><li class="navelem"><a class="el" href="classglib_1_1_compression.html">Compression</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#nested-classes">Classes</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="#pub-static-attribs">Static Public Attributes</a> &#124;
<a href="classglib_1_1_compression-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">glib::Compression Class Reference</div></div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="nested-classes" name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglib_1_1_compression_1_1_d_e_f_l_a_t_e___i_n_v_a_l_i_d___m_o_d_e.html">DEFLATE_INVALID_MODE</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglib_1_1_compression_1_1_h_u_f_f_m_a_n___c_a_n_o_n_i_c_a_l___e_r_r_o_r.html">HUFFMAN_CANONICAL_ERROR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglib_1_1_compression_1_1_h_u_f_f_m_a_n___t_r_e_e___e_r_r_o_r.html">HUFFMAN_TREE_ERROR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglib_1_1_compression_1_1_l_z_s_s___e_r_r_o_r.html">LZSS_ERROR</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglib_1_1_compression_1_1_l_z_w___e_r_r_o_r___l317.html">LZW_ERROR_L317</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structglib_1_1_compression_1_1_l_z_w___e_r_r_o_r___l340.html">LZW_ERROR_L340</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-methods" name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a99c51ecc8b192a605d3643ecb739cce4"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a99c51ecc8b192a605d3643ecb739cce4">compressRLE</a> (unsigned char *data, int size)</td></tr>
<tr class="memdesc:a99c51ecc8b192a605d3643ecb739cce4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using Run Length Encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.  <a href="classglib_1_1_compression.html#a99c51ecc8b192a605d3643ecb739cce4">More...</a><br /></td></tr>
<tr class="separator:a99c51ecc8b192a605d3643ecb739cce4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abdaba02ef12d485e2b3291cb78c7c7f7"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#abdaba02ef12d485e2b3291cb78c7c7f7">compressRLE</a> (std::vector&lt; unsigned char &gt; data)</td></tr>
<tr class="memdesc:abdaba02ef12d485e2b3291cb78c7c7f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using Run Length Encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown.  <a href="classglib_1_1_compression.html#abdaba02ef12d485e2b3291cb78c7c7f7">More...</a><br /></td></tr>
<tr class="separator:abdaba02ef12d485e2b3291cb78c7c7f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae22ceede7191be8a325e091ee9bced09"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#ae22ceede7191be8a325e091ee9bced09">decompressRLE</a> (unsigned char *data, int size, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:ae22ceede7191be8a325e091ee9bced09"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses Run Length Encoded data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#ae22ceede7191be8a325e091ee9bced09">More...</a><br /></td></tr>
<tr class="separator:ae22ceede7191be8a325e091ee9bced09"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3c459eba34a4f69eb6f7d1c28f35d1c5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a3c459eba34a4f69eb6f7d1c28f35d1c5">decompressRLE</a> (std::vector&lt; unsigned char &gt; data, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:a3c459eba34a4f69eb6f7d1c28f35d1c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses Run Length Encoded data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#a3c459eba34a4f69eb6f7d1c28f35d1c5">More...</a><br /></td></tr>
<tr class="separator:a3c459eba34a4f69eb6f7d1c28f35d1c5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cdc7e2d405c844ceef65a767922a0d5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a7cdc7e2d405c844ceef65a767922a0d5">decompressLZW</a> (unsigned char *data, int size, int dictionarySize, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:a7cdc7e2d405c844ceef65a767922a0d5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#a7cdc7e2d405c844ceef65a767922a0d5">More...</a><br /></td></tr>
<tr class="separator:a7cdc7e2d405c844ceef65a767922a0d5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad70dae407e26323202890fd26cebe0ec"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#ad70dae407e26323202890fd26cebe0ec">decompressLZW</a> (std::vector&lt; unsigned char &gt; data, int dictionarySize, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:ad70dae407e26323202890fd26cebe0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#ad70dae407e26323202890fd26cebe0ec">More...</a><br /></td></tr>
<tr class="separator:ad70dae407e26323202890fd26cebe0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa4be40123669395a679bb15d11a18527"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#aa4be40123669395a679bb15d11a18527">compressLZW</a> (unsigned char *data, int size, int *codeSizePointer=nullptr)</td></tr>
<tr class="memdesc:aa4be40123669395a679bb15d11a18527"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.  <a href="classglib_1_1_compression.html#aa4be40123669395a679bb15d11a18527">More...</a><br /></td></tr>
<tr class="separator:aa4be40123669395a679bb15d11a18527"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af806f23b1457ee45ce0db19043ad7058"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#af806f23b1457ee45ce0db19043ad7058">compressLZW</a> (std::vector&lt; unsigned char &gt; data, int *codeSizePointer=nullptr)</td></tr>
<tr class="memdesc:af806f23b1457ee45ce0db19043ad7058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown.  <a href="classglib_1_1_compression.html#af806f23b1457ee45ce0db19043ad7058">More...</a><br /></td></tr>
<tr class="separator:af806f23b1457ee45ce0db19043ad7058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a230897b9e25977485e7fcd28b57d683b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a230897b9e25977485e7fcd28b57d683b">compressLZ77</a> (unsigned char *data, int size, int maxBufferSize=0x7FFF)</td></tr>
<tr class="memdesc:a230897b9e25977485e7fcd28b57d683b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.  <a href="classglib_1_1_compression.html#a230897b9e25977485e7fcd28b57d683b">More...</a><br /></td></tr>
<tr class="separator:a230897b9e25977485e7fcd28b57d683b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6dd2e3b0adfc1309a7980c4d0779f210"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a6dd2e3b0adfc1309a7980c4d0779f210">compressLZ77</a> (std::vector&lt; unsigned char &gt; data, int maxBufferSize=0x7FFF)</td></tr>
<tr class="memdesc:a6dd2e3b0adfc1309a7980c4d0779f210"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown.  <a href="classglib_1_1_compression.html#a6dd2e3b0adfc1309a7980c4d0779f210">More...</a><br /></td></tr>
<tr class="separator:a6dd2e3b0adfc1309a7980c4d0779f210"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8786b97b7ef12eb150752a89d73d6af2"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a8786b97b7ef12eb150752a89d73d6af2">decompressLZ77</a> (unsigned char *data, int size, int maxBufferSize=0x7FFF, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:a8786b97b7ef12eb150752a89d73d6af2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#a8786b97b7ef12eb150752a89d73d6af2">More...</a><br /></td></tr>
<tr class="separator:a8786b97b7ef12eb150752a89d73d6af2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4d893442c90e9464c96f4e20994db137"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a4d893442c90e9464c96f4e20994db137">decompressLZ77</a> (std::vector&lt; unsigned char &gt; data, int maxBufferSize=0x7FFF, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:a4d893442c90e9464c96f4e20994db137"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#a4d893442c90e9464c96f4e20994db137">More...</a><br /></td></tr>
<tr class="separator:a4d893442c90e9464c96f4e20994db137"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3f7018fe21ec94a9ba2332eb31d173b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#ac3f7018fe21ec94a9ba2332eb31d173b">compressLZSS</a> (unsigned char *data, int size)</td></tr>
<tr class="memdesc:ac3f7018fe21ec94a9ba2332eb31d173b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using LZSS (Lempel Ziv Storer Szymanski) If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.  <a href="classglib_1_1_compression.html#ac3f7018fe21ec94a9ba2332eb31d173b">More...</a><br /></td></tr>
<tr class="separator:ac3f7018fe21ec94a9ba2332eb31d173b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a565c87acb428b9e401ce2d21dbbb315a"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a565c87acb428b9e401ce2d21dbbb315a">compressLZSS</a> (std::vector&lt; unsigned char &gt; data)</td></tr>
<tr class="memdesc:a565c87acb428b9e401ce2d21dbbb315a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using LZSS (Lempel Ziv Storer Szymanski) If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown.  <a href="classglib_1_1_compression.html#a565c87acb428b9e401ce2d21dbbb315a">More...</a><br /></td></tr>
<tr class="separator:a565c87acb428b9e401ce2d21dbbb315a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa2863204e5ca4b3e49b325d3093305e5"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#aa2863204e5ca4b3e49b325d3093305e5">decompressLZSS</a> (unsigned char *data, int size, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:aa2863204e5ca4b3e49b325d3093305e5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses LZSS (Lempel Ziv Storer Szymanski) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#aa2863204e5ca4b3e49b325d3093305e5">More...</a><br /></td></tr>
<tr class="separator:aa2863204e5ca4b3e49b325d3093305e5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac023a5127506e1c9080934f068caafb6"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#ac023a5127506e1c9080934f068caafb6">decompressLZSS</a> (std::vector&lt; unsigned char &gt; data, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:ac023a5127506e1c9080934f068caafb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses LZSS (Lempel Ziv Storer Szymanski) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is.  <a href="classglib_1_1_compression.html#ac023a5127506e1c9080934f068caafb6">More...</a><br /></td></tr>
<tr class="separator:ac023a5127506e1c9080934f068caafb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa426e858821491c5dae797f7adb80d92"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#aa426e858821491c5dae797f7adb80d92">compressHuffman</a> (unsigned char *data, int size, <a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *tree)</td></tr>
<tr class="memdesc:aa426e858821491c5dae797f7adb80d92"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using a Huffman tree. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.  <a href="classglib_1_1_compression.html#aa426e858821491c5dae797f7adb80d92">More...</a><br /></td></tr>
<tr class="separator:aa426e858821491c5dae797f7adb80d92"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a331f0f1a152d15e8bbd156cd80f3078b"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a331f0f1a152d15e8bbd156cd80f3078b">compressHuffman</a> (std::vector&lt; unsigned char &gt; data, <a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *tree)</td></tr>
<tr class="memdesc:a331f0f1a152d15e8bbd156cd80f3078b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using a Huffman tree. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown.  <a href="classglib_1_1_compression.html#a331f0f1a152d15e8bbd156cd80f3078b">More...</a><br /></td></tr>
<tr class="separator:a331f0f1a152d15e8bbd156cd80f3078b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af92bd3d465631fd51be81d96e3ec98a0"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#af92bd3d465631fd51be81d96e3ec98a0">decompressHuffman</a> (unsigned char *data, int size, <a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *tree, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:af92bd3d465631fd51be81d96e3ec98a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses data using Huffman tree encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. If the tree is invalid for any reason such as being null or not being able to resolve data and USE_EXCEPTIONS is defined, a <a class="el" href="structglib_1_1_compression_1_1_h_u_f_f_m_a_n___t_r_e_e___e_r_r_o_r.html">HUFFMAN_TREE_ERROR</a> is thrown.  <a href="classglib_1_1_compression.html#af92bd3d465631fd51be81d96e3ec98a0">More...</a><br /></td></tr>
<tr class="separator:af92bd3d465631fd51be81d96e3ec98a0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3654c50c6a42190de76cf2e3ee033058"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a3654c50c6a42190de76cf2e3ee033058">decompressHuffman</a> (std::vector&lt; unsigned char &gt; data, <a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *tree, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:a3654c50c6a42190de76cf2e3ee033058"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses data using Huffman tree encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. If the tree is invalid for any reason such as being null or not being able to resolve data and USE_EXCEPTIONS is defined, a <a class="el" href="structglib_1_1_compression_1_1_h_u_f_f_m_a_n___t_r_e_e___e_r_r_o_r.html">HUFFMAN_TREE_ERROR</a> is thrown.  <a href="classglib_1_1_compression.html#a3654c50c6a42190de76cf2e3ee033058">More...</a><br /></td></tr>
<tr class="separator:a3654c50c6a42190de76cf2e3ee033058"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0aed705eee96ea7f90fec8d0ed295fa1"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a0aed705eee96ea7f90fec8d0ed295fa1"><td class="memTemplItemLeft" align="right" valign="top">static <a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a0aed705eee96ea7f90fec8d0ed295fa1">buildHuffmanTree</a> (T *data, int size, int maxCodeLength=-1)</td></tr>
<tr class="memdesc:a0aed705eee96ea7f90fec8d0ed295fa1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a huffman tree from the specified data array. A length limited huffman tree can be created this way as well if desired. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.  <a href="classglib_1_1_compression.html#a0aed705eee96ea7f90fec8d0ed295fa1">More...</a><br /></td></tr>
<tr class="separator:a0aed705eee96ea7f90fec8d0ed295fa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87bc6fbc91ffa40578e20c664ed06ca9"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a87bc6fbc91ffa40578e20c664ed06ca9">buildCanonicalHuffmanTree</a> (int *dataValue, int sizeOfData, int *codeLength, int sizeOfCodeLengths, bool separateCodes=true, bool rmsb=false)</td></tr>
<tr class="memdesc:a87bc6fbc91ffa40578e20c664ed06ca9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a Canonical Huffman Tree based on the parameters given. The data can be given where each value in the dataValue array has a unique code length given in the codeLength array at the same spot or they can be separate where the codeLengths array tells how many codes have length specified by its index. Both representations are used in different data formats.  <a href="classglib_1_1_compression.html#a87bc6fbc91ffa40578e20c664ed06ca9">More...</a><br /></td></tr>
<tr class="separator:a87bc6fbc91ffa40578e20c664ed06ca9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab064e441a5cc3452fa952665ceca207e"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#ab064e441a5cc3452fa952665ceca207e">compressDeflate</a> (unsigned char *data, int size, int blocks, int compressionLevel=7, bool customTable=false)</td></tr>
<tr class="memdesc:ab064e441a5cc3452fa952665ceca207e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using DELFATE.  <a href="classglib_1_1_compression.html#ab064e441a5cc3452fa952665ceca207e">More...</a><br /></td></tr>
<tr class="separator:ab064e441a5cc3452fa952665ceca207e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afd776206d5d7e80a2f398a3b40207e89"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#afd776206d5d7e80a2f398a3b40207e89">compressDeflate</a> (std::vector&lt; unsigned char &gt; data, int blocks, int compressionLevel=7, bool customTable=false)</td></tr>
<tr class="memdesc:afd776206d5d7e80a2f398a3b40207e89"><td class="mdescLeft">&#160;</td><td class="mdescRight">Compresses data using DELFATE.  <a href="classglib_1_1_compression.html#afd776206d5d7e80a2f398a3b40207e89">More...</a><br /></td></tr>
<tr class="separator:afd776206d5d7e80a2f398a3b40207e89"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afc1c7fe6d49ab02fdc77caa32e363989"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#afc1c7fe6d49ab02fdc77caa32e363989">decompressDeflate</a> (unsigned char *data, int size, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:afc1c7fe6d49ab02fdc77caa32e363989"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses a DEFLATE data stream.  <a href="classglib_1_1_compression.html#afc1c7fe6d49ab02fdc77caa32e363989">More...</a><br /></td></tr>
<tr class="separator:afc1c7fe6d49ab02fdc77caa32e363989"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af744cae176359d2040f9095f5d69145a"><td class="memItemLeft" align="right" valign="top">static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#af744cae176359d2040f9095f5d69145a">decompressDeflate</a> (std::vector&lt; unsigned char &gt; data, size_t expectedSize=-1)</td></tr>
<tr class="memdesc:af744cae176359d2040f9095f5d69145a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Decompresses a DEFLATE data stream.  <a href="classglib_1_1_compression.html#af744cae176359d2040f9095f5d69145a">More...</a><br /></td></tr>
<tr class="separator:af744cae176359d2040f9095f5d69145a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3711fc2c6eb9c3c23e3850f1413295fb"><td class="memItemLeft" align="right" valign="top"><a id="a3711fc2c6eb9c3c23e3850f1413295fb" name="a3711fc2c6eb9c3c23e3850f1413295fb"></a>
static double&#160;</td><td class="memItemRight" valign="bottom"><b>compressArithmetic</b> (std::vector&lt; unsigned char &gt; data, std::vector&lt; double &gt; &amp;percentages)</td></tr>
<tr class="memdesc:a3711fc2c6eb9c3c23e3850f1413295fb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental Arithmetic compression. Should not be used currently. <br /></td></tr>
<tr class="separator:a3711fc2c6eb9c3c23e3850f1413295fb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ade5cc012fe95dc3dfa39f1fce8b5c7a9"><td class="memItemLeft" align="right" valign="top"><a id="ade5cc012fe95dc3dfa39f1fce8b5c7a9" name="ade5cc012fe95dc3dfa39f1fce8b5c7a9"></a>
static std::vector&lt; unsigned char &gt;&#160;</td><td class="memItemRight" valign="bottom"><b>decompressArithmetic</b> (double data, int messageSize, std::vector&lt; double &gt; percentages)</td></tr>
<tr class="memdesc:ade5cc012fe95dc3dfa39f1fce8b5c7a9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Experimental Arithmetic decompression. Should not be used currently. <br /></td></tr>
<tr class="separator:ade5cc012fe95dc3dfa39f1fce8b5c7a9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aae23326302c9f9a1fe329ad6974c019a"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#aae23326302c9f9a1fe329ad6974c019a">adler32</a> (unsigned char *data, int size)</td></tr>
<tr class="memdesc:aae23326302c9f9a1fe329ad6974c019a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a checksum using ADLER32. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.  <a href="classglib_1_1_compression.html#aae23326302c9f9a1fe329ad6974c019a">More...</a><br /></td></tr>
<tr class="separator:aae23326302c9f9a1fe329ad6974c019a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0758870d09fbd7a3711514b6c3115e3d"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#a0758870d09fbd7a3711514b6c3115e3d">adler32</a> (std::vector&lt; unsigned char &gt; data)</td></tr>
<tr class="memdesc:a0758870d09fbd7a3711514b6c3115e3d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a checksum using ADLER32. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown.  <a href="classglib_1_1_compression.html#a0758870d09fbd7a3711514b6c3115e3d">More...</a><br /></td></tr>
<tr class="separator:a0758870d09fbd7a3711514b6c3115e3d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc706e49226e01336b0201a89a53f7f5"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#abc706e49226e01336b0201a89a53f7f5">crc</a> (unsigned char *data, int size, unsigned char type=CRC_32)</td></tr>
<tr class="memdesc:abc706e49226e01336b0201a89a53f7f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a checksum using CRC. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. Three CRC methods are available: CRC_8 CRC_16 CRC_32.  <a href="classglib_1_1_compression.html#abc706e49226e01336b0201a89a53f7f5">More...</a><br /></td></tr>
<tr class="separator:abc706e49226e01336b0201a89a53f7f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa89f1360029855cf7c818ef6de9c33a2"><td class="memItemLeft" align="right" valign="top">static unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classglib_1_1_compression.html#aa89f1360029855cf7c818ef6de9c33a2">crc</a> (std::vector&lt; unsigned char &gt; data, unsigned char type=CRC_32)</td></tr>
<tr class="memdesc:aa89f1360029855cf7c818ef6de9c33a2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates a checksum using CRC. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. Three CRC methods are available: CRC_8 CRC_16 CRC_32.  <a href="classglib_1_1_compression.html#aa89f1360029855cf7c818ef6de9c33a2">More...</a><br /></td></tr>
<tr class="separator:aa89f1360029855cf7c818ef6de9c33a2"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-static-attribs" name="pub-static-attribs"></a>
Static Public Attributes</h2></td></tr>
<tr class="memitem:a9636159170282e9e7508400d6172efac"><td class="memItemLeft" align="right" valign="top"><a id="a9636159170282e9e7508400d6172efac" name="a9636159170282e9e7508400d6172efac"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>CRC_8</b> = 0</td></tr>
<tr class="separator:a9636159170282e9e7508400d6172efac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad8316faf46e4a93b01e2c3b28022d703"><td class="memItemLeft" align="right" valign="top"><a id="ad8316faf46e4a93b01e2c3b28022d703" name="ad8316faf46e4a93b01e2c3b28022d703"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>CRC_16</b> = 1</td></tr>
<tr class="separator:ad8316faf46e4a93b01e2c3b28022d703"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad058873c3602fcaeee30ba1636c31c88"><td class="memItemLeft" align="right" valign="top"><a id="ad058873c3602fcaeee30ba1636c31c88" name="ad058873c3602fcaeee30ba1636c31c88"></a>
static const unsigned char&#160;</td><td class="memItemRight" valign="bottom"><b>CRC_32</b> = 2</td></tr>
<tr class="separator:ad058873c3602fcaeee30ba1636c31c88"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a0758870d09fbd7a3711514b6c3115e3d" name="a0758870d09fbd7a3711514b6c3115e3d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0758870d09fbd7a3711514b6c3115e3d">&#9670;&nbsp;</a></span>adler32() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int glib::Compression::adler32 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a checksum using ADLER32. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to generate the checksum from </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int Returns a valid checksum if successful. Otherwise, 0 is returned. Note that 0 can be a valid checksum return. </dd></dl>

</div>
</div>
<a id="aae23326302c9f9a1fe329ad6974c019a" name="aae23326302c9f9a1fe329ad6974c019a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aae23326302c9f9a1fe329ad6974c019a">&#9670;&nbsp;</a></span>adler32() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int glib::Compression::adler32 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a checksum using ADLER32. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to generate the checksum from </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int Returns a valid checksum if successful. Otherwise, 0 is returned. Note that 0 can be a valid checksum return. </dd></dl>

</div>
</div>
<a id="a87bc6fbc91ffa40578e20c664ed06ca9" name="a87bc6fbc91ffa40578e20c664ed06ca9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87bc6fbc91ffa40578e20c664ed06ca9">&#9670;&nbsp;</a></span>buildCanonicalHuffmanTree()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; * glib::Compression::buildCanonicalHuffmanTree </td>
          <td>(</td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>dataValue</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeOfData</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>codeLength</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>sizeOfCodeLengths</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>separateCodes</em> = <code>true</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>rmsb</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Create a Canonical Huffman Tree based on the parameters given. The data can be given where each value in the dataValue array has a unique code length given in the codeLength array at the same spot or they can be separate where the codeLengths array tells how many codes have length specified by its index. Both representations are used in different data formats. </p>
<p >If the size of data is 0 or less or there is not enough data to map code lengths to the data, and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dataValue</td><td>The data values used. </td></tr>
    <tr><td class="paramname">sizeOfData</td><td>The size of the dataValue array. </td></tr>
    <tr><td class="paramname">codeLengths</td><td>The code lengths for the data. </td></tr>
    <tr><td class="paramname">sizeOfCodeLengths</td><td>The size of the codeLength array. </td></tr>
    <tr><td class="paramname">separateCodes</td><td>Whether or not the code lengths have a one to one mapping. If false, codeLength[i] must specify the length of dataValue[i] and the sizes must match. Default value is true </td></tr>
    <tr><td class="paramname">rmsb</td><td>Determines whether the code values will be in LMSB or RMSB order. Default is false | which is LMSB </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0aed705eee96ea7f90fec8d0ed295fa1" name="a0aed705eee96ea7f90fec8d0ed295fa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0aed705eee96ea7f90fec8d0ed295fa1">&#9670;&nbsp;</a></span>buildHuffmanTree()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; * glib::Compression::buildHuffmanTree </td>
          <td>(</td>
          <td class="paramtype">T *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxCodeLength</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Creates a huffman tree from the specified data array. A length limited huffman tree can be created this way as well if desired. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to create a huffman tree from. It should be a numerical data type as the data will be cast to ints to find the tree. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">maxCodeLength</td><td>The maximum code length allowed for the tree. A value less than 0 will create a huffman tree that is not length limited. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>BinaryTree&lt;HuffmanNode&gt; Returns a valid huffman tree if successful. Otherwise, returns a nullptr. </dd></dl>

</div>
</div>
<a id="afd776206d5d7e80a2f398a3b40207e89" name="afd776206d5d7e80a2f398a3b40207e89"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afd776206d5d7e80a2f398a3b40207e89">&#9670;&nbsp;</a></span>compressDeflate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressDeflate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>customTable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using DELFATE. </p>
<pre class="fragment">    If the size of data is 0 or blocks is 0 and USE_EXCEPTIONS is defined, an InvalidSizeError is thrown.

    This method will use multiple threads to compress to maintain reasonable speed unless the amount of blocks is 1.
    Custom huffman trees are supported.
    Uses a zlib header.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">blocks</td><td>The amount of blocks to separate the data into for compression. Adding more blocks allows multiple threads to compress them individually but can reduce the compression ratio. </td></tr>
    <tr><td class="paramname">compressionLevel</td><td>Changing the compression level adjusts the maximum backwards distance allowed. The lowest backwards distance is 256 where compressionLevel is set to 0 The maximum distance is 32768 where compressionLevel is set to 7 Default value is 7 </td></tr>
    <tr><td class="paramname">customTable</td><td>Chooses whether to use a custom huffman table for compression. Slower but results in a unique table for each block and better compression. Default value is false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns a valid deflate stream using a zlib header as a std::vector&lt;unsigned char&gt;. Otherwise, returns an empty vector. </dd></dl>

</div>
</div>
<a id="ab064e441a5cc3452fa952665ceca207e" name="ab064e441a5cc3452fa952665ceca207e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab064e441a5cc3452fa952665ceca207e">&#9670;&nbsp;</a></span>compressDeflate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressDeflate </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>blocks</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>compressionLevel</em> = <code>7</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>customTable</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using DELFATE. </p>
<pre class="fragment">    If the size of data is 0 or blocks is 0 and USE_EXCEPTIONS is defined, an InvalidSizeError is thrown.
    If the data pointer is nullptr and USE_EXCEPTIONS is defined, an InvalidDataError is thrown.

    This method will use multiple threads to compress to maintain reasonable speed unless the amount of blocks is 1.
    Custom huffman trees are supported.
    Uses a zlib header.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">blocks</td><td>The amount of blocks to separate the data into for compression. Adding more blocks allows multiple threads to compress them individually but can reduce the compression ratio. </td></tr>
    <tr><td class="paramname">compressionLevel</td><td>Changing the compression level adjusts the maximum backwards distance allowed. The lowest backwards distance is 256 where compressionLevel is set to 0 The maximum distance is 32768 where compressionLevel is set to 7 Default value is 7 </td></tr>
    <tr><td class="paramname">customTable</td><td>Chooses whether to use a custom huffman table for compression. Slower but results in a unique table for each block and better compression. Default value is false </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns a valid deflate stream using a zlib header as a std::vector&lt;unsigned char&gt;. Otherwise, returns an empty vector. </dd></dl>

</div>
</div>
<a id="a331f0f1a152d15e8bbd156cd80f3078b" name="a331f0f1a152d15e8bbd156cd80f3078b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a331f0f1a152d15e8bbd156cd80f3078b">&#9670;&nbsp;</a></span>compressHuffman() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressHuffman </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using a Huffman tree. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">tree</td><td>The pointer that will store the huffman tree generated. Must be a valid pointer and should not have any data stored in it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector and the tree pointer should have the huffman tree used to compress the data. </dd></dl>

</div>
</div>
<a id="aa426e858821491c5dae797f7adb80d92" name="aa426e858821491c5dae797f7adb80d92"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa426e858821491c5dae797f7adb80d92">&#9670;&nbsp;</a></span>compressHuffman() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressHuffman </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using a Huffman tree. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">tree</td><td>The pointer that will store the huffman tree generated. Must be a valid pointer and should not have any data stored in it. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector and the tree pointer should have the huffman tree used to compress the data. </dd></dl>

</div>
</div>
<a id="a6dd2e3b0adfc1309a7980c4d0779f210" name="a6dd2e3b0adfc1309a7980c4d0779f210"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6dd2e3b0adfc1309a7980c4d0779f210">&#9670;&nbsp;</a></span>compressLZ77() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressLZ77 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0x7FFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. </p>
<p >The output uses triplets with the format (back_distance, copy_length, literal) The maximum buffer size also specifies how many bytes are used for the back_distance and copy_length in each distance by using the log base 2 of the maxBufferSize. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>The maximum allowed backwards distance allowed for compression in the sliding window. Default is 32767 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector. </dd></dl>

</div>
</div>
<a id="a230897b9e25977485e7fcd28b57d683b" name="a230897b9e25977485e7fcd28b57d683b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a230897b9e25977485e7fcd28b57d683b">&#9670;&nbsp;</a></span>compressLZ77() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressLZ77 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0x7FFF</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. </p>
<p >The output uses triplets with the format (back_distance, copy_length, literal) The maximum buffer size also specifies how many bytes are used for the back_distance and copy_length in each distance by using the log base 2 of the maxBufferSize. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>The maximum allowed backwards distance allowed for compression in the sliding window. Default is 32767 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector. </dd></dl>

</div>
</div>
<a id="a565c87acb428b9e401ce2d21dbbb315a" name="a565c87acb428b9e401ce2d21dbbb315a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a565c87acb428b9e401ce2d21dbbb315a">&#9670;&nbsp;</a></span>compressLZSS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressLZSS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using LZSS (Lempel Ziv Storer Szymanski) If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. </p>
<p >The output uses 9 bits for a literal or 24 bits for a reference pair The first bit specifies if it is a literal or not. If literal, the next 8 bits are the value. In a referencePair, the backwards distance is 15 bits and the copy length is 8 bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector. </dd></dl>

</div>
</div>
<a id="ac3f7018fe21ec94a9ba2332eb31d173b" name="ac3f7018fe21ec94a9ba2332eb31d173b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3f7018fe21ec94a9ba2332eb31d173b">&#9670;&nbsp;</a></span>compressLZSS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressLZSS </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using LZSS (Lempel Ziv Storer Szymanski) If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. </p>
<p >The output uses 9 bits for a literal or 24 bits for a reference pair The first bit specifies if it is a literal or not. If literal, the next 8 bits are the value. In a referencePair, the backwards distance is 15 bits and the copy length is 8 bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector. </dd></dl>

</div>
</div>
<a id="af806f23b1457ee45ce0db19043ad7058" name="af806f23b1457ee45ce0db19043ad7058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af806f23b1457ee45ce0db19043ad7058">&#9670;&nbsp;</a></span>compressLZW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressLZW </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>codeSizePointer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress </td></tr>
    <tr><td class="paramname">codeSizePointer</td><td>A pointer to the code size parameter that should be used to compress the data. If left as a nullptr, the code size paramter will be determined by the function. If the code size is less that or equal to 0, the function will determine the code size and modify the pointer to reflect that. Default is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector. </dd></dl>

</div>
</div>
<a id="aa4be40123669395a679bb15d11a18527" name="aa4be40123669395a679bb15d11a18527"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa4be40123669395a679bb15d11a18527">&#9670;&nbsp;</a></span>compressLZW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressLZW </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int *&#160;</td>
          <td class="paramname"><em>codeSizePointer</em> = <code>nullptr</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">codeSizePointer</td><td>A pointer to the code size parameter that should be used to compress the data. If left as a nullptr, the code size paramter will be determined by the function. If the code size is less that or equal to 0, the function will determine the code size and modify the pointer to reflect that. Default is nullptr. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector. </dd></dl>

</div>
</div>
<a id="abdaba02ef12d485e2b3291cb78c7c7f7" name="abdaba02ef12d485e2b3291cb78c7c7f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abdaba02ef12d485e2b3291cb78c7c7f7">&#9670;&nbsp;</a></span>compressRLE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressRLE </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using Run Length Encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. </p>
<p >Data is compressed as bytes where the run is specified first, then the data is specified after. Run is a byte in size and the data is a byte in size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector so that it can be saved into a file later if desired. </dd></dl>

</div>
</div>
<a id="a99c51ecc8b192a605d3643ecb739cce4" name="a99c51ecc8b192a605d3643ecb739cce4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a99c51ecc8b192a605d3643ecb739cce4">&#9670;&nbsp;</a></span>compressRLE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::compressRLE </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Compresses data using Run Length Encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. </p>
<p >Data is compressed as bytes where the run is specified first, then the data is specified after. Run is a byte in size and the data is a byte in size. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the compressed data as a vector so that it can be saved into a file later if desired. </dd></dl>

</div>
</div>
<a id="aa89f1360029855cf7c818ef6de9c33a2" name="aa89f1360029855cf7c818ef6de9c33a2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa89f1360029855cf7c818ef6de9c33a2">&#9670;&nbsp;</a></span>crc() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int glib::Compression::crc </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>type</em> = <code>CRC_32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a checksum using CRC. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. Three CRC methods are available: CRC_8 CRC_16 CRC_32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to generate the checksum from </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">type</td><td>The type of CRC to use. DEFAULT is CRC_32 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int Returns a valid checksum if successful. Otherwise, 0 is returned. Note that 0 can be a valid checksum return. </dd></dl>

</div>
</div>
<a id="abc706e49226e01336b0201a89a53f7f5" name="abc706e49226e01336b0201a89a53f7f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abc706e49226e01336b0201a89a53f7f5">&#9670;&nbsp;</a></span>crc() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static unsigned int glib::Compression::crc </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">unsigned char&#160;</td>
          <td class="paramname"><em>type</em> = <code>CRC_32</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates a checksum using CRC. If the size of data is 0 and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. Three CRC methods are available: CRC_8 CRC_16 CRC_32. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to generate the checksum from </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">type</td><td>The type of CRC to use. DEFAULT is CRC_32 </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>unsigned int Returns a valid checksum if successful. Otherwise, 0 is returned. Note that 0 can be a valid checksum return. </dd></dl>

</div>
</div>
<a id="af744cae176359d2040f9095f5d69145a" name="af744cae176359d2040f9095f5d69145a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af744cae176359d2040f9095f5d69145a">&#9670;&nbsp;</a></span>decompressDeflate() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressDeflate </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses a DEFLATE data stream. </p>
<pre class="fragment">    If the size of data is 0 or blocks is 0 and USE_EXCEPTIONS is defined, an InvalidSizeError is thrown.
    If the data pointer is nullptr and USE_EXCEPTIONS is defined, an InvalidDataError is thrown.

    Assumes that the data uses a ZLIB header. GZIP is not supported.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data. Otherwise, an empty vector is returned. </dd></dl>

</div>
</div>
<a id="afc1c7fe6d49ab02fdc77caa32e363989" name="afc1c7fe6d49ab02fdc77caa32e363989"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afc1c7fe6d49ab02fdc77caa32e363989">&#9670;&nbsp;</a></span>decompressDeflate() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressDeflate </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses a DEFLATE data stream. </p>
<pre class="fragment">    If the size of data is 0 or blocks is 0 and USE_EXCEPTIONS is defined, an InvalidSizeError is thrown.
    If the data pointer is nullptr and USE_EXCEPTIONS is defined, an InvalidDataError is thrown.

    Assumes that the data uses a ZLIB header. GZIP is not supported.
</pre> <dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data. Otherwise, an empty vector is returned. </dd></dl>

</div>
</div>
<a id="a3654c50c6a42190de76cf2e3ee033058" name="a3654c50c6a42190de76cf2e3ee033058"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3654c50c6a42190de76cf2e3ee033058">&#9670;&nbsp;</a></span>decompressHuffman() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressHuffman </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses data using Huffman tree encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. If the tree is invalid for any reason such as being null or not being able to resolve data and USE_EXCEPTIONS is defined, a <a class="el" href="structglib_1_1_compression_1_1_h_u_f_f_m_a_n___t_r_e_e___e_r_r_o_r.html">HUFFMAN_TREE_ERROR</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">tree</td><td>The huffman tree to use for decompression </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<a id="af92bd3d465631fd51be81d96e3ec98a0" name="af92bd3d465631fd51be81d96e3ec98a0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af92bd3d465631fd51be81d96e3ec98a0">&#9670;&nbsp;</a></span>decompressHuffman() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressHuffman </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classglib_1_1_binary_tree.html">BinaryTree</a>&lt; <a class="el" href="structglib_1_1_huffman_node.html">HuffmanNode</a> &gt; *&#160;</td>
          <td class="paramname"><em>tree</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses data using Huffman tree encoding. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. If the tree is invalid for any reason such as being null or not being able to resolve data and USE_EXCEPTIONS is defined, a <a class="el" href="structglib_1_1_compression_1_1_h_u_f_f_m_a_n___t_r_e_e___e_r_r_o_r.html">HUFFMAN_TREE_ERROR</a> is thrown. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">tree</td><td>The huffman tree to use for decompression </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<a id="a4d893442c90e9464c96f4e20994db137" name="a4d893442c90e9464c96f4e20994db137"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a4d893442c90e9464c96f4e20994db137">&#9670;&nbsp;</a></span>decompressLZ77() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressLZ77 </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0x7FFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<p >The input is expected to use triplets with the format (back_distance, copy_length, literal) The maximum buffer size also specifies how many bytes are used for the back_distance and copy_length in each distance by using the log base 2 of the maxBufferSize. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>The maximum allowed backwards distance allowed for compression in the sliding window. Default is 32767. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<a id="a8786b97b7ef12eb150752a89d73d6af2" name="a8786b97b7ef12eb150752a89d73d6af2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8786b97b7ef12eb150752a89d73d6af2">&#9670;&nbsp;</a></span>decompressLZ77() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressLZ77 </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>maxBufferSize</em> = <code>0x7FFF</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses LZ77 (Lempel Ziv 77) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<p >The input is expected to use triplets with the format (back_distance, copy_length, literal) The maximum buffer size also specifies how many bytes are used for the back_distance and copy_length in each distance by using the log base 2 of the maxBufferSize. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">maxBufferSize</td><td>The maximum allowed backwards distance allowed for compression in the sliding window. Default is 32767. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<a id="ac023a5127506e1c9080934f068caafb6" name="ac023a5127506e1c9080934f068caafb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac023a5127506e1c9080934f068caafb6">&#9670;&nbsp;</a></span>decompressLZSS() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressLZSS </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses LZSS (Lempel Ziv Storer Szymanski) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<p >The input expects the format to be the same as the compression methods. The first bit specifies if it is a literal or not. If literal, the next 8 bits are the value. In a referencePair, the backwards distance is 15 bits and the copy length is 8 bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<a id="aa2863204e5ca4b3e49b325d3093305e5" name="aa2863204e5ca4b3e49b325d3093305e5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa2863204e5ca4b3e49b325d3093305e5">&#9670;&nbsp;</a></span>decompressLZSS() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressLZSS </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses LZSS (Lempel Ziv Storer Szymanski) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<p >The input expects the format to be the same as the compression methods. The first bit specifies if it is a literal or not. If literal, the next 8 bits are the value. In a referencePair, the backwards distance is 15 bits and the copy length is 8 bits. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to compress. </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<a id="ad70dae407e26323202890fd26cebe0ec" name="ad70dae407e26323202890fd26cebe0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad70dae407e26323202890fd26cebe0ec">&#9670;&nbsp;</a></span>decompressLZW() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressLZW </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dictionarySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">dictionarySize</td><td>The size of the dictionary used to compress the data. Required to decompress. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. The decompressed data will just be the indicies in the dictionary. The original dictionary is still needed to fully decompress the data. </dd></dl>

</div>
</div>
<a id="a7cdc7e2d405c844ceef65a767922a0d5" name="a7cdc7e2d405c844ceef65a767922a0d5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7cdc7e2d405c844ceef65a767922a0d5">&#9670;&nbsp;</a></span>decompressLZW() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressLZW </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>dictionarySize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses LZW (Lempel Ziv Welch) data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">dictionarySize</td><td>The size of the dictionary used to compress the data. Required to decompress. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. The decompressed data will just be the indicies in the dictionary. The original dictionary is still needed to fully decompress the data. </dd></dl>

</div>
</div>
<a id="a3c459eba34a4f69eb6f7d1c28f35d1c5" name="a3c459eba34a4f69eb6f7d1c28f35d1c5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3c459eba34a4f69eb6f7d1c28f35d1c5">&#9670;&nbsp;</a></span>decompressRLE() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressRLE </td>
          <td>(</td>
          <td class="paramtype">std::vector&lt; unsigned char &gt;&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses Run Length Encoded data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<p >The data is expected to have both run and the data as bytes. Run is expected to be first and the data second. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<a id="ae22ceede7191be8a325e091ee9bced09" name="ae22ceede7191be8a325e091ee9bced09"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae22ceede7191be8a325e091ee9bced09">&#9670;&nbsp;</a></span>decompressRLE() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static std::vector&lt; unsigned char &gt; glib::Compression::decompressRLE </td>
          <td>(</td>
          <td class="paramtype">unsigned char *&#160;</td>
          <td class="paramname"><em>data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>expectedSize</em> = <code>-1</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Decompresses Run Length Encoded data. If the size of data is 0 or less and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_size_error.html">InvalidSizeError</a> is thrown. If the data pointer is nullptr and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_invalid_data_error.html">InvalidDataError</a> is thrown. If the output exceeds the expected size and USE_EXCEPTIONS is defined, an <a class="el" href="structglib_1_1_compression_1_1_exceeded_expected_size_error.html">ExceededExpectedSizeError</a> is thrown. If USE_EXCEPTIONS is not defined, the current decompressed data is returned as is. </p>
<p >The data is expected to have both run and the data as bytes. Run is expected to be first and the data second. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">data</td><td>The data to decompress </td></tr>
    <tr><td class="paramname">size</td><td>The size of the data. </td></tr>
    <tr><td class="paramname">expectedSize</td><td>The expected size of the decompressed data. Set this if you know what the data size should be when decompressed. By default, it is set to the max that a vector can store. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>std::vector&lt;unsigned char&gt; If successful, returns the decompressed data as a vector. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>include/<a class="el" href="_compression_8h_source.html">Compression.h</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.2
</small></address>
</body>
</html>
